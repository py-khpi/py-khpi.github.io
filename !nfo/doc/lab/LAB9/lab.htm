<!doctype html>
<HTML lang="ru">                                     
<HEAD>
<meta charset="utf-8">
<title>Лабораторная работа 9: Регулярные выражения</title>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../heads.css">
<style>
</style>
</HEAD>
<BODY>
<H1> ЛАБОРАТОРНАЯ РАБОТА №9</H1>
<H2> <SPAN CLASS="beg" >Тема: </SPAN>Регулярные выражения</H2>
<H2> <SPAN CLASS="beg" >Цель: </SPAN>
Изучение средств языка Python для работы с регулярными выражениями</H2>
<A NAME="beg"></A>
<H3>ОГЛАВЛЕНИЕ</H3> 
<A CLASS="com" HREF="#vve"> Введение<BR>
<A CLASS="com" HREF="#1">1 Синтаксис регулярных выражений<BR>
<A CLASS="com" HREF="#1">1.1 Представление символов<BR>
<A CLASS="com" HREF="#1.2">1.2 Позиция внутри строки<BR>
<A CLASS="com" HREF="#1.3">1.3 Квалификаторы повторения<BR>
<A CLASS="com" HREF="#2">2 Функции, методы и константы регулярных выражений<BR>
<A CLASS="com" HREF="#2">2.1 Модуль re<BR>
<A CLASS="com1" HREF="#2.1.1">2.1.1 Константы модуля re <BR>
<A CLASS="com1" HREF="#2.1.2">2.1.2 Функции модуля re<BR>
<A CLASS="com" HREF="#2.2">2.2 Методы объектов класса RegexpObject<BR> 
<A CLASS="com" HREF="#2.3">2.3 Методы объектов класса MatchObject <BR>
<A CLASS="com" HREF="#2.4">2.4 Использование скобок в регулярных выражениях<BR>
<A CLASS="com" HREF="#3">3 Использование регулярных выражений<BR>
<A CLASS="com" HREF="#prim1">Пример №1<BR>
<A CLASS="com" HREF="#ind">Индивидуальные задания<BR>
<A NAME="vve"></A>     
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>                       

<H4>Введение</H4>
<P>Регулярные выражения (англ. regular expressions, сокр. RegExp) &ndash; это формальный язык
поиска подстрок в тексте и осуществления манипуляций с ними, основанный на использовании
метасимволов (англ. wildcard characters). По сути это шаблон (англ. pattern), строка-образец,
состоящая из символов и метасимволов и задающая правило поиска.<BR>
<SPAN CLASS="txt_abz">Регулярные </SPAN>выражения (РВ) изобрел американский математик, один из
основателей направления "Компьютерные науки" Стефан Клини (Stephen Kleene), который описал
поведение модели нейрона, предложенной в 1940-х гг. Уорреном Маккалоком и Уолтером Питтсом,
используя свою систему математических обозначений, названную им "регулярные множества".<BR>
<SPAN CLASS="txt_abz">Регулярные </SPAN>выражения произвели прорыв в электронной обработке текстов
в конце XX века. Многие современные языки программирования имеют встроенную поддержку регулярных
выражений. Среди них Perl, Java, PHP, Python, JavaScript и многие др.<BR>
<SPAN CLASS="txt_abz">Вместе </SPAN>с тем, необходимо заметить, что не все возможные задачи
обработки текста могут быть решены с помощью РВ, поскольку язык регулярных выражений относительно
прост и ограничен. Кроме того, в отдельных случаях, когда РВ имеют сложную форму, бывает проще
решить задачу, применив код на языке Python, который может работать быстрее и иметь более простой
вид.  	 
<A NAME="1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4>1 Синтаксис регулярных выражений</H4>
<H4 CLASS="pod">1.1 Представление символов</H4>
<P> Большинство символов в регулярном выражении являются простыми символами, т.е. такими, которые
представляют сами себя, за исключением символов <span class="meta">[ ] \ ^ $ . | ? * + ( )
{ }</span>, которые являются метасимволами. К метасимволам также относятся некоторые простые
символы с предшествующим символом <span style="color:blue;">\</span> (обратный слеш). Метасимволы в
РВ имеют следующиее назначение:
<UL CLASS="list">
<LI> <span class="meta">[ ]</span> &ndash; набор символов в квадратных скобках именуется символьным классом и позволяет
указать интерпретатору регулярных выражений, что на данном месте в строке может стоять один из
перечисленных символов. В частности, [abc] задает возможность появления в тексте одной из букв:
"a", "b" или "c". <BR>
<SPAN CLASS="txt_abz">Если </SPAN> символы идут подряд, можно указать диапазон: например, [abc]
эквивалентно [a-c], а символьный класс [А-Яа-я] соответствует всем буквам русского алфавита
(за исключением букв "Ё" и "ё"). <BR>
<SPAN CLASS="txt_abz">Если </SPAN>требуется задать символы, которые не могут стоять на данном месте
в строке, то внутри квадратных скобок первым символом указывается символ
<span class="meta">^</span>, например, [^A] означает любой символ, кроме "A". <BR>
<SPAN CLASS="txt_abz">Если </SPAN>внутри класса стоит метасимвол, он утрачивает свое специальное
значие, например, [ab$] &ndash; означает, что в строке на этом месте могут стоять символы "a", "b"
или "$";
<LI> <span class="meta">.</span> &ndash; означает любой один символ (кроме символов новой строки);
<LI> <span class="meta">\</span> &ndash; если стоит перед метасимволом, экранирует его, т.е. делает
обычным символом, например, \. &ndash; представляет обычную точку в тексте. И наоборот, символ \,
стоящий перед обычным символом, делает его метасимволом, например, \d &ndash; обозначает любую
цифру.<BR>
<SPAN CLASS="txt_abz">Для </SPAN>представления символа "\", который является метасимволом, в
регулярном выражении как обычного символа, не имеющено специального значения, необходимо указать
"\\". Поскольку РВ в языке Python являются строками, то, с учетом этого, символ "\" будет
представлен в регулярном выражении как "\\\\". Чтобы этого избежать, можно воспользоваться
префиксом "r" (см. <a href="../LAB2/lab.htm#2.1">подраздел 2.1 </a> лаб. раб. №2), который
создает строку, в которой все символы представляют сами себя. Таким образом '\n' является
односимвольной строкой, представляющей символ новой строки, а r'\n' &ndash; строкой, состоящей из
двух символов ("\" и "n"). Обычно используюется этот способ задания регулярных выражений;
<LI> <span class="meta">[\b]</span> &ndash; символ backspace, не путать с \b, обозначающим границу
слова ( см. <a href="#1.2">подраздел 1.2</a>);
<LI> <span class="meta">\cx</span> &ndash; комбинация клавиш CTRL-x, где x &ndash; буква от A до Z,
например, \cM означает CTRL-M;
<LI> <span class="meta">\d</span> &ndash; любая цифра от 0 до 9 (эквивалентно классу [0-9]);
<LI> <span class="meta">\D</span> &ndash; любой нецифровой символ;            
<LI> <span class="meta">\f</span> &ndash; символ новой страницы;
<LI> <span class="meta">\n</span> &ndash; символ новой строки;
<LI> <span class="meta">\r</span> &ndash; символ возврата каретки;
<LI> <span class="meta">\s</span> &ndash; любой разделительный символ (эквивалентно классу
[ \t\n\r\f\v]);
<LI> <span class="meta">\S</span> &ndash; все, за исключением перечисленного в /s (эквивалентно
классу [^ \t\n\r\f\v]). Поэтому для указания в регулярном выражении того, что на этом месте может
стоять любой символ текста, можно использовать символьный класс [\s\S];
<LI> <span class="meta">\t</span> &ndash; символ табуляции;
<LI> <span class="meta">\v</span> &ndash; символ вертикальной табуляции;
<LI> <span class="meta">\w</span> &ndash; латинская буква, цифра или знак подчеркивания
(эквивалентно классу [A-Za-z0-9_]);
<LI> <span class="meta">\W</span> &ndash; все, за исключением перечисленного в \w;
<LI> <span class="meta">|</span> &ndash; разделяет допустимые варианты. Например, gray|grey
соответствует gray или grey. Перебор вариантов выполняется слева направо. Если требуется указать
перечень вариантов внутри более сложного РВ, то его нужно заключить в группу. Например, вариант
gr[ae]y предпочтителен, так как сравнение с символьным классом выполняется проще, чем обработка
группы с проверкой на все ее возможные модификаторы;
<LI> <span class="meta">\0</span> &ndash; None;  
<LI> <span class="meta">\k</span> &ndash; обратная ссылка на запомненную k-й парой скобок
подстроку.
</UL><P>
<A NAME="1.2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.2 Позиция внутри строки</H4>
<P>Следующие метасимволы позволяют спозиционировать регулярное выражение относительно элементов
текста: начала и конца строки, границ слова:
<UL CLASS="list">
<LI> <span class="meta">^</span> &ndash; начало строки (позиция перед первым символом строки), т.е. проверяемый текст
должен обязательно начинаться с начала строки;
<LI> <span class="meta">$</span> &ndash; конец строки (позиция после последнего символа строки), т.е. проверяемый текст
должен обязательно заканчиваться в конце строки;
<LI> <span class="meta">\b</span> &ndash; граница слова;
<LI> <span class="meta">\B</span> &ndash; не граница слова;
<LI> <span class="meta">\A</span> &ndash; начало строки, но в отличие от символа ^ не изменяет свое
значение при наличии флага M;
<LI> <span class="meta">\Z</span> &ndash; конец строки, но в отличие от символа $ не изменяет свое
значение при наличии флага M.
</UL>
<A NAME="1.3"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.3 Квалификаторы повторения</H4>
<P> Квалификатор (англ. qualifier) повторения после символа, символьного класса или группы
(см. <a href="#2.4">подраздел 2.4 </a>) определяет, сколько раз предшествующее выражение может
встречаться в строке:
<UL CLASS="list">
<LI> <span class="meta">{n}</span> &ndash; ровно n;
<LI> <span class="meta">{m,n}</span> &ndash; от m до n включительно;
<LI> <span class="meta">{m,}</span> &ndash; не менее m;
<LI> <span class="meta">{,n}</span> &ndash; не более n;
<LI> <span class="meta">*</span> (звезда Клини) &ndash; ноль или более, т.е. может и не встречаться;
<LI> <span class="meta">+</span> &ndash; один или более;
<LI> <span class="meta">?</span> &ndash; ноль или один.
</UL>
<P>Если символы <SPAN CLASS="svoj">{ }</SPAN> не образуют квалификатор, их специальное значение
игнорируется.
<A NAME="2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>
          
<H4>2 Функции, методы и константы регулярных выражений </H4>
<A NAME="2.1"></A>
<H4 CLASS="pod">2.1 Модуль re</H4>
<P>Для работы с регулярными выражениями на языке Python необходимо подключить модуль
<SPAN CLASS="svoj">re</SPAN>, который содержит описания функций, констант и исключения. <BR>
<SPAN CLASS="txt_abz"> Регулярные </SPAN>выражения на языке Python могут быть заданы в двух формах:
<UL CLASS="list">
<LI> в виде шаблонов регулярных выражений, представленных строками (класс str);
<LI> в виде объектов регулярных выражений, полученных из шаблонов РВ путем их компиляции (класс
RegexpObject).
</UL>
<P>Компиляция осуществляется с помощью функции <SPAN CLASS="svoj">compile(pattern[,flags])</SPAN>
модуля <SPAN CLASS="svoj">re</SPAN>, которая компилирует шаблон РВ
<SPAN CLASS="svoj">pattern</SPAN>, заданный в виде строки, и возвращает результат в виде объекта
регулярного выражеиния (экземпляра класса <SPAN CLASS="svoj">RegexpObject</SPAN>). Необязательный
параметр <SPAN CLASS="svoj">flags</SPAN> позволяет модифицировать поведение регулярного выражения
(см. <a href="#2.1.1">подраздел 2.1.1 </a>). <BR>
<SPAN CLASS="txt_abz">Использование </SPAN>объектов РВ, которые имеют свои методы поиска
(см. <a href="#2.2">подраздел 2.2 </a>), вместо шаблонов РВ позволяет ускорить работу с регулярными
выражениями. Кроме того, последние используемые объекты РВ кэшируются и не требуют повторной
компиляции. Методы объектов РВ имеют дополнительные возможности по сравнению с функциями модуля
<SPAN CLASS="svoj">re</SPAN>. Поэтому большинство нетривиальных решений использует именно объекты
регулярных выражений. 
<A NAME="2.1.1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod1">2.1.1 Константы модуля re</H4>
<P>Модуль <SPAN CLASS="svoj">re</SPAN> содержит константы, которые задают значения следующих
флагов регулярных выражений, используемых в функциях модуля <SPAN CLASS="svoj">re</SPAN>
(см. <a href="#2.1.2">подраздел 2.1.2 </a>) (в скобках показана сокращенная форма флага):
<UL CLASS="list">
<LI> <span class="meta">ASCII (A) </span> &ndash; позволяет осуществлять сравнение при
использовании \w, \W, \b, \B, \d, \D, \s и \S только с символами, заданными в ASCII-коде (вместо
использования кода Unicode). Имеет смысл для шаблонов, заданных в коде Unicode; 
<LI> <span class="meta">IGNORECASE (I) </span> &ndash; позволяет игнорировать регистр символов; 
<LI> <span class="meta">LOCALE (L)</span> &ndash; позволяет учитывать при использовании \w, \W, \b,
\B,\d, \D, \s и \S локальную кодировку (например, для некоторызх французких букв); 
<LI> <span class="meta">MULTILINE (M) </span> &ndash; позволяет символу '^' в строке, содержащей
несколько символов новой строки, указывать начало поиска не только с начала строки, но и с
начала каждой части строки, следующей за символом ('\n'), а символу '$' указывать окончание поиска
не только в конце строки, но и перед каждым символом ('\n'); 
<LI> <span class="meta">DOTALL (S) </span> &ndash; позволяет специальному символу '.' представлять
любой символ, включая символ новой строки (без этого флага символ '.' представлял любой символ, не
включая символа новой строки); 
<LI> <span class="meta">VERBOSE (X)</span> &ndash; позволяет задать регулярное выражение в виде,
более ясном для понимания. При этом в РВ разрешается ставить разделительные символы (кроме тех, что указаны в
символьных классах или тех, которые следуют за символом обратного слэша). Кроме того, в регулярном
выражении можно указывать комментарии (используя символ '#'). Например, следующие два регулярных
выражений эквивалентны (первое использует флаг X, второе &ndash; нет):<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">import </SPAN>
<SPAN STYLE="font-size:7mm; color:black">re</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black"> a = re.compile(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r"""\d +  # the integral part</SPAN><BR>
<SPAN STYLE="margin-left:8.8cm; font-size:7mm; color:green">\.    # the decimal point </SPAN><BR>
<SPAN STYLE="margin-left:8.8cm; font-size:7mm; color:green">
\d *  # some fractional digits"""</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, re.X)</SPAN>;<BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">b = re.compile(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r"\d+\.\d*"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN>;<BR>
</UL>
<A NAME="2.1.2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod1">2.1.2 Функции модуля re</H4>
<P>Помимо функции <SPAN CLASS="svoj">compile()</SPAN> (см. <a href="#2">подраздел 2.1 </a>) модуль
<SPAN CLASS="svoj">re</SPAN> содержит следующие функции:                 
<UL CLASS="list">
<LI> <span class="meta">search(pattern, string[, flags])</span> &ndash; просматривает строку
string, сравнивая ее подстроки с шаблоном регулярного выражения pattern. При обнаружении такой 
подстроки &ndash; возвращает объект, экземпляр класса MatchObject. В противном случае &ndash; 
возвращает значение None;
<LI> <span class="meta">match(pattern, string[, flags])</span> &ndash; если нуль или больше
символов начала строки string совпадают с шаблоном РВ pattern &ndash; возвращает объект, экземпляр
класса MatchObject. В противном случае &ndash; возвращает значение None;
<LI> <span class="meta">split(pattern, string[, maxsplit=0, flags=0])</span> &ndash; разделяет
строку string на подстроки и возвращает список подстрок. Разделителем служит шаблон РВ pattern.
Необязательный параметр maxsplit указывает индекс последнего элемента списка. При этом оставшаяся
часть строки добавляется в этот последний элемент:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">re.split(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'-','1-2-3-4-5-6'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">['1', '2', '3', '4', '5', '6']
</SPAN> <BR> 
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">re.split(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'-','1-2-3-4-5-6'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,3)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">['1', '2', '3', '4-5-6']</SPAN>.
<BR> <BR>
Если шаблон РВ взять в скобки, то содержимое шаблона будет включено в результирующий список
подстрок:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">re.split(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'(-)','1-2-3-4-5-6'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
['1', '-', '2', '-', '3', '-', '4', '-', '5', '-', '6'] </SPAN>; <BR> <BR>
<LI> <span class="meta">findall(pattern, string[, flags])</span> &ndash; возвращает список
подстрок, найденных с помощью шаблона РВ pattern в строке string. При этом строка сканируется
слева направо и совпадения включаются в список в порядке их обнаружения. Если одна или более групп
указана в шаблоне, то возращается список групп. Это будет список кортежей, если шаблон имеет более
одной группы:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">re.findall(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'(-)','r'\d','2 cats and 3 dogs'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">['2', '3'] </SPAN>; <BR> <BR>
<LI> <span class="meta">finditer(pattern, string[, flags])</span> &ndash; возвращает найденные с
помощью шаблона pattern подстроки строки string в виде итератора;
<LI> <span class="meta">sub(pattern, repl, string[, count, flags])</span> &ndash; возвращает
строку, полученную путем замены самой левой подстроки, найденной шаблоном РВ pattern, в строке
string на значение repl. Если подстрока не найдена &ndash; возращается исходная строка. Параметр
repl может быть строкой или функцией. <BR>
<SPAN CLASS="txt_abz">Если </SPAN>это строка, то любой обратный слэш в esc-последовательности будет
обрабатываться. Это значит, что "\n" преобразуется в символ новой строки. Неизвестная
esc-последовательность, такая как "\j", остается без изменения. Обратные ссылки, такие как \6,
заменяются подстрокой, найденной группой 6 регулярного выражения:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">s=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'It\'s a cat\n'</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">re.sub(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'cat'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'small cat'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,s)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">"It's a small cat\n"</SPAN>.<BR><BR>
<SPAN CLASS="txt_abz">Если </SPAN>это функция, она вызывается по каждому непересекающемуся
совпадению с шаблоном. Функция получает единственный аргумент в виде объекта типа match и
возвращает значение в виде измененной строки;
<LI> <span class="meta">subn(pattern, repl, string[, count, flags])</span> &ndash; выполняет те же
операции, что и функция sub(), но возвращает кортеж, элементами которого явзяются: измененная
строка и число подстановок;
<LI> <span class="meta">escape(string)</span> &ndash; возвращает строку string с добавлением
обратых слэшей ко всем символам, не являющимися цифрами или буквами. Это бывает полезно сделать
в случае поиска в произвольной строке, которая может содержать метасимволы РВ:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">re.escape(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'^Hello, world!#'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'\\^Hello\\,\\ world\\!\\#'</SPAN>;
<BR><BR>
<LI> <span class="meta">purge</span>() &ndash; очищает кэш регулярных выражений;
</UL>
<A NAME="2.2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 class="pod">2.2 Методы объектов класса RegexpObject</H4>
<P>Объекты регулярных выражений (экземпляры класса <SPAN CLASS="svoj">RegexpObject</SPAN>)
возвращает функция <SPAN CLASS="svoj">compile()</SPAN> модуля <SPAN CLASS="svoj">re</SPAN> в
результате компиляции регулярных выражений, заданных в виде шаблона-строки
(см. <a href="#2">подраздел 2.1 </a>):<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">import </SPAN>
<SPAN STYLE="font-size:7mm; color:black">re</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p=re.compile(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'ab*'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN>. <BR><BR>
<p>Объекты класса <SPAN CLASS="svoj">RegexpObject</SPAN> имеют следующие методы:
<UL CLASS="list">      
<LI> <span class="meta">search(string[, pos[, endpos]])</span> &ndash; осуществляет поиск вдоль
строки string, определяя местоположение подстроки, совпадающей с РВ, и в случае совпадения
возвращает соответствующий экземпляр класса MatchObject. Если такое место в строке не найдено
&ndash; возвращает значение None. Отметим, что это не одно и то же, что найти в некотором месте
строки сравнение нулевой длины.<BR>
<SPAN CLASS="txt_abz">Необязательный </SPAN>параметр pos задает позицию в строке, где начинается
поиск. Это не полностью эквивалентно использованию метоасимвола "^", который указывает и на начало
строки, и на начало каждой части строки, начинающейся символом новой строки.<BR>
<SPAN CLASS="txt_abz">Необязательный </SPAN>параметр endpos задает границу поиска в строке (могут
сравниваться только символы с индексами не больше endpos - 1). Если endpos меньше pos &ndash;
сравнение не будет осуществляться:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p.search(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'the absolute'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
&lt;_sre.SRE_Match object; span=(4, 6), match='ab'></SPAN>; <BR> <BR>
<LI> <span class="meta">match(string[, pos[, endpos]])</span> &ndash; если нуль или более символов
строки string совпадают с РВ, возвращает соответствующий экземпляр класса MatchObject. В противном
случае возвращает значение None. Необязательные параметры pos и endpos имеют те же назначение, что
и для метода search():<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p.match(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'abba'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
&lt;_sre.SRE_Match object; span=(0, 3), match='abb'></SPAN>. <BR> <BR>
Если подстрока не найдена &ndash; возвращается значение None:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(p.match(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">''Abba''</SPAN>
<SPAN STYLE="font-size:7mm; color:black">))</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">None</SPAN>; <BR><BR>
Если подстрока не начинается с начала строки, она не находится:<BR><BR> 
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">if not </SPAN>
<SPAN STYLE="font-size:7mm; color:black">p.match(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">' abba''</SPAN>
<SPAN STYLE="font-size:7mm; color:black">): </SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">( </SPAN>
<SPAN STYLE="font-size:7mm; color:green">'Подстрока не найдена'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">Подстрока не найдена</SPAN>,<BR><BR>
В этом случае необходимо использовать метод search();
<LI> <span class="meta">split(string[, maxsplit=0])</span> &ndash; идентичен функции split() модуля 
re, но использует скомпилированное РВ в виде объекта класса RegexpObject; 
<LI> <span class="meta">findall(string[, pos[, endpos]])</span> &ndash; идентичен функции findall()
модуля re, но использует скомпилированное РВ в виде объекта класса RegexpObject. Также может
принимать необязательные параметры pos и endpos, для задания диапазона поиска подобно методу
match() :<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p.findall(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">''"abba\'s" music - abcolute''</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
['abb', 'a', 'ab']</SPAN>;  <BR> <BR>
<LI> <span class="meta">finditer(string[, pos[, endpos]])</span> &ndash; идентичен функции
finditer() модуля re, но использует скомпилированное РВ в виде объекта класса RegexpObject. Также
может принимать необязательные параметры pos и endpos, для задания диапазона поиска подобно методу
match();
<LI> <span class="meta">sub(repl, string[, count=0])</span> &ndash; идентичен функции sub()
модуля re, но использует скомпилированное РВ в виде объекта класса RegexpObject; 
<LI> <span class="meta">subn(repl, string[, count=0])</span> &ndash; идентичен функции
subn() модуля re, но использует скомпилированное РВ в виде объекта класса RegexpObject. 
</UL>
<A NAME="2.3"></A>  
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>                          

<H4 CLASS="pod">2.3 Методы объектов класса MatchObject</H4>
<P>Функции <SPAN CLASS="svoj">search()</SPAN> и <SPAN CLASS="svoj">match()</SPAN> модуля
<SPAN CLASS="svoj">re</SPAN>, а также методы <SPAN CLASS="svoj">search()</SPAN> и
<SPAN CLASS="svoj">match()</SPAN> объектов класса <SPAN CLASS="svoj">RegexpObject</SPAN> при
успешном поиске возвращают значения в виде объектов класса <SPAN CLASS="svoj">MatchObject</SPAN>: 
<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">r=p.match(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'abba'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">r</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
&lt;_sre.SRE_Match object; span=(0, 3), match='abb'></SPAN>. 
<p>В противном случае возвращаеют значение None:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(p.match( </SPAN>
<SPAN STYLE="font-size:7mm; color:green">'cat'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">None </SPAN>.	
<p>Объекты класса <SPAN CLASS="svoj">MatchObject</SPAN> имеют следующие методы:
<UL CLASS="list">      
<LI> group([group1, ...]) &ndash; возвращает одну или больше найденных групп
(см. <a href="#2.4">подраздел 2.4</a>). Если аргументы не заданы, принимается значение по умолчанию &ndash;
нуль, в этом случае возращается вся найденная подстрока:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">r.group()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'abb'</SPAN>;<BR><BR>
Если указан единственный аргумент, результатом будет единственная строка. Если указано несколько
аргументов, результатом будет кортеж, каждый элемент которого задает одну строку:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN> 
<SPAN STYLE="font-size:7mm; color:black">m=re.match(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r"(\w+)\s(\w+)"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"Isaac Newton, physicist"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN> 
<SPAN STYLE="font-size:7mm; color:black">m.group()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'Isaac Newton'</SPAN>;<BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN> 
<SPAN STYLE="font-size:7mm; color:black">m.group(1)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'Isaac'</SPAN>;<BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN> 
<SPAN STYLE="font-size:7mm; color:black">m.group(2)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'Newton'</SPAN>;<BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN> 
<SPAN STYLE="font-size:7mm; color:black">m.group(1, 2)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">('Isaac', 'Newton')</SPAN>;<BR><BR>
<LI> groups([defaults]) &ndash; возвращает кортеж, содержащий все сравненные группы. Значение по
умолчанию (None) указывается для тех групп, для которых не произошло сравнение:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN> 
<SPAN STYLE="font-size:7mm; color:black">m=re.match(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r"(\d+)\.(\d+)"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"25.341"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN> 
<SPAN STYLE="font-size:7mm; color:black">m.groups()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">('25', '341')</SPAN>;<BR><BR>
<LI> groupdict([default]) &ndash; возвращает словарь, содержащий все именованные группы
(см. <a href="#2.4">подраздел 2.4</a>), ключами которого являются имена этих групп. Аргумент по
умоляанию (None) используется для тех групп, которые не принимали участие в сравнении. 
<LI> start([group])<br>
end([group]) &ndash; возвращают начальный и конечный индексы найденной подстроки:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">r.start()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">0;<BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">r.end()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">3;<BR><BR>
<LI> span([group]) &ndash; возвращает кортеж, содержащий позицию (start,end) подстроки:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">r.span()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">(0,3).<BR><BR>
</UL>
<p>Метод <SPAN CLASS="svoj">span()</SPAN> можно также использовать для просмотра позиций найленных
подстрок итератора, полученного методом <SPAN CLASS="svoj">p.finditer()</SPAN>:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">ite=p.finditer(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'"abba\'s" music - abcolute '</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">ite</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
&lt;callable_iterator object at 0x02308EB0> <BR> 
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">for </SPAN>
<SPAN STYLE="font-size:7mm; color:black">m</SPAN> 
<SPAN STYLE="font-size:7mm; color:#ff8000">in </SPAN>
<SPAN STYLE="font-size:7mm; color:black">ite:</SPAN> 
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(m.span())</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">(1, 4) <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">(4, 5) <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">(17, 19)
<p>
<A NAME="2.4"></A>   
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>                         

<H4 CLASS="pod">2.4 Использование скобок в регулярных выражениях</H4>
<P>Для обозначения группы символов регулярного выражения используются круглые скобки, которые,
являясь метасимволами, определяют операции, их область действия и приоритет над указанными в
группе символами. <BR>
<SPAN CLASS="txt_abz">В </SPAN>настоящее время скобкам регулярных выражений уделяется особое
внимание. Например, разработчики последних версий языка PERL дальнейшее развитие РВ видят не в
создании новых метасимволов или разработке новых методов, а в использовании скобок для задания
специальных выражений, расширяющих функциональные возможности регулярных выражений. По этому пути
пошли и разработчики яыка Python &ndash; для указания особенностей регурярных выражений языка
Python в скобках помещается буква "P" (см. ниже). <BR>
<SPAN CLASS="txt_abz">Шаблон </SPAN> внутри группы обрабатывается как единое целое, может быть
квалифицирован и выполняет сделующие функции:
<UL CLASS="list">
<LI> <span class="meta">(. . .)</span> &ndash; находит и запоминает подстроку согласно РВ ". . .".
Это "скобки с запоминанием". Они, во-первых, выполняют типичную для них роль объединения отдельных
частей в единое целое (как в математике), например (abc){3} &ndash; означает троекратное повторение
последовательности букв abc. Во-вторых, они запоминают в памяти результаты поиска, к которым в
последствии можно обратиться. Для задания в строке символов '(' и ')', представляющих самих себя,
можно использовать обратные слэши: \( и \) или символьные классы [(] и [)]. Например, скобки могут
быть использованы при преобразовании даты из формата "ММ/ДД/ГГГГ" в формат "ДД.ММ.ГГГГ". При этом
в регулярном выражении создаются три пары скобок, содержащие РВ для поиска трех подстрок: первая
&ndash; цифр номера месяца, вторая &ndash; цифр дня месяца, третья &ndash; цифр года: <BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">date=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'03/11/2016'</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">m=re.match(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r'(\d{1,2})/(\d{1,2})/(\d{4})$'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,date)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">if </SPAN>
<SPAN STYLE="font-size:7mm; color:black">m:</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(m.group(2),</SPAN>
<SPAN STYLE="font-size:7mm; color:green"> '.'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, m.group(1),</SPAN>
<SPAN STYLE="font-size:7mm; color:green"> '.'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, m.group(3), sep= </SPAN>
<SPAN STYLE="font-size:7mm; color:green">''</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#ff8000">else </SPAN>
<SPAN STYLE="font-size:7mm; color:black">: </SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'Дата задана неверно'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">11.03.2016 </SPAN>; <BR><BR>
<LI> <span class="meta">(?: . . . )</span> &ndash; это "скобки без запоминания". Они выполняют
только функцию объединения. Поэтому, если результат группы в дальнейшем не понадобится, лучше
использовать этот вид группирования. Это повышает скорость выполнения;
<LI> <span class="meta">(?aiLmsux)</span> &ndash; один или более символов из набора 'a', 'i', 'L',
'm', 's', 'u', 'x' указывает на наличие в РВ соответствующего флага
(см. <a href="#2.1.1">подраздел 2.1.1</a>): re.A (сравнение только с ASCII-символами),
re.I (игнорируется регистр), re.L (зависимость от внутренней кодировки), re.M (строка содержит
несколько символов \n), re.S (точка сравнивает все) и re.X (удобный вид). Поиск слов без
использования флага IGNORECASE: <BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p=re.compile(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r'[A-Z]\w+'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p.findall(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'The cat and the dog'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">['The']</SPAN><BR><BR>
и с использованием флага IGNORECASE: <BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p=re.compile(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r'(?i)[A-Z]\w+'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p.findall(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'The cat and the dog'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
['The', 'cat', 'and', 'the', 'dog']</SPAN>;<BR><BR>
<LI> <span class="meta">(?P&lt;name>. . .)</span> &ndash; задает имя группы name. В дальнейшем по
этому имени можно обращаться к группе. Имена групп в пределах регулярного выражения должны
различаться: <BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">m=re.match(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r'(?P&lt;first_name>\w+)\s(?P&lt;second_name>\w+)'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN> 
<SPAN STYLE="font-size:7mm; color:green">'Isaac Newton'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">m.group(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'first_name'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'Isaac'</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">m.group(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'second_name'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'Newton'</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">m.group()</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'Isaac Newton'</SPAN>; <BR><BR>
<LI> <span class="meta">(?= . . .)</span> &ndash; находит сравнение, если только дальше следует
". . . ". Например, метод sub() заменяет в строке s строчные буквы i на заглавные I только в
названиях фирмы:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">s=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">
'Фирма intel выпускает процессоры серии intel Core: i7, i5 и i3'</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p=re.compile(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'i(?=ntel)'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p.sub(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'I'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,s)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
'Фирма Intel выпускает процессоры серии Intel Core: i7, i5 и i3'; <BR><BR>
<LI> <span class="meta">(?! . . . )</span> &ndash; находит подстроку, если только дальше не следует
". . . ". Например, РВ не находит в строке первое слово "a", поскольку дальше следует пробел
:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p=re.compile(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r'a\w+(?!\s)'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p.search(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'a atom'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue"> 'atom';<BR><BR>
<LI> <span class="meta">(?&lt;= . . . )</span> &ndash; находит подстроку, если только ей 
предшествоовало ". . . ". Например, РВ находит в строке только те числа, которым предшествовал
символ "№":<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p=re.compile(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r'(?<=№)\d+'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p.findall(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'1, №2, №33, 4, 55'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">['2', '33'];<BR><BR>
<LI> <span class="meta">(?&lt;! . . . )</span> &ndash; находит подстроку, если только ей не 
предшествовало ". . . "; 
</UL>
<P>Одно из применений группирования &ndash; повторное использование ранее найденных групп символов
(подстрок, блоков, отмеченных подвыражений). При обработке выражения подстроки, найденные по
шаблону внутри группы, сохраняются в памяти и получают номер начиная с единицы. Каждой подстроке
соответствует пара скобок в регулярном выражении. Python поддерживается до 99 нумерованных подстрок
с номерами от 1 до 99. В регулярном выражении можно ссылаться на раннее найденные группы по их
номерам, используя обратный слэш &ndash; \1 - \99. Например, найдем в строке повторяющиеся слова:
<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>	
<SPAN STYLE="font-size:7mm; color:black">p=re.compile(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r'(\b\w+)\s+\1'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">p.search(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'The cat and the the dog'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">).group()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'the the'</SPAN>.<BR>
<A NAME="3"></A>                            
<TABLE WIDTH=70%  ALIGN=CENTER BORDER=0>
<TR><TD ALIGN=right>
<A CLASS="out" HREF="#beg">Оглавление</A>
</TABLE>

<H4>3 Использование регулярных выражений</H4>
<P>Использование регулярных выражений для проверки данных пользователя показано в клиент-серверном
приложении, клиентская часть которого реализована в виде <a href="#prim1">примера №1</a>,
содержащего HTML-форму, которая имеет текстовое поле для ввода фамилии и инициалов пользователя
("user_name") и две кнопки: "Сброс" и  "Передать данные":
<A NAME="prim1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<P><A CLASS="out" HREF="prim1.htm">Пример №1</A><BR><BR>
<SPAN CLASS="html">&lt;!DOCTYPE html> </SPAN><BR>
<SPAN CLASS="html">&lt;html&gt;<BR>
<SPAN CLASS="html">&lt;head&gt;<BR>
<SPAN CLASS="html">&lt;title>Передача данных серверу для проверки&lt;/title><BR>
<SPAN CLASS="html">&lt;link rel="stylesheet" href="file:///D:/!PYTHON/lab.css"><BR>
<SPAN CLASS="html">&lt;/head&gt;<BR>
<SPAN CLASS="html">&lt;body&gt;<BR>
<SPAN CLASS="html">&lt;h1>Передача данных серверу для проверки&lt;/h1><BR>
<SPAN CLASS="html">&lt;form method="get" action="http://zykov/PYTHON/get_data_form.py"><BR>
<SPAN CLASS="html">Введите фамилию и инициалы:<BR>
<SPAN CLASS="html">&lt;input type="text" class="form" name="user_name">&lt;br>&lt;br><BR>
<SPAN CLASS="html">&lt;input type="reset" value="Сброс" class="kn"&gt;&amp;nbsp;&amp;nbsp;<BR>
<SPAN CLASS="html">&lt;input type="submit" value="Передать данные" class="kn"&gt;<BR>
<SPAN CLASS="html">&lt;/form><BR>
<SPAN CLASS="html">&lt;/body><BR>
<SPAN CLASS="html">&lt;/html>
<P> После ввода пользователем своей фамилии и инициалов и нажатия кнопки "Передать данные"
браузер отправляет введенные данные серверному приложению
<SPAN CLASS="svoj">get_data_form.py</SPAN>:
<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:red">
#!c: . . . /Python35-32/python.exe</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"Content-Type: text/html\n"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#FF8000">import</SPAN>
<SPAN STYLE="font-size:7mm; color:black">cgi, cgitb, my_cgi, re</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">cgitb.enable()</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">user_name=cgi.parse()[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"user_name"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">][0]</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(my_cgi.H,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">
"Проверка данных пользоваетеля с помощью регулярных выражений"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">p=re.compile(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">r'^([А-Я][а-я]+)\s[А-Я]\.[А-Я]\.$'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">m=p.match(user_name)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#FF8000">if</SPAN>
<SPAN STYLE="font-size:7mm; color:black">m:</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(my_cgi.H2,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"Тов. "</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, m.group(1),</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"!"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, sep=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">""</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(my_cgi.D,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"Данные введены правильно."</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#FF8000">else</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(my_cgi.D,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"Данные введены неправильно."</SPAN>
<SPAN STYLE="font-size:7mm; color:black">),</SPAN>
<p> которое выполняет следующие действия:
<UL CLASS="list">   
<LI> в первых строках указывает путь к интерпретатору языка Python 3.3 и формирует
http-заголовок;
<LI> подключает модули языка Python (cgi, cgitb и re), а также пользовательский модуль
my_cgi, который содержит форматы для представления данных, отсылаемых клиенту;
<LI> инициализирует обработчик ошибок модуля cgitb с заданием значений по умолчанию;                                         
<LI> с помощью метода cgi.parse() получает фамилию и инициалы пользователя (переменная user_name);
<LI> сообщает пользователю о начале проверки его данных;
<LI> создает шаблон соответствующего регулярного выражения и компилирует его с помощью функции
compile(), получая экземпляр класса RegexpObject (переменная p);
<LI>осуществляет сравнение с помощью метода match() введенных данных с объектом регулярного
выражения, получая экземпляр класса MatchObject (переменная m); 
<LI> если значение m не равно None, то пользователю сообщается:
<P STYLE='text-align:center;color:#00b0b0; font-size:7.5mm; font-style:italic'
>Тов. Петров! </p> 
<p STYLE='margin-left:1.5cm;color:#0000b0; font-size:6.5mm'>Данные введены правильно.
</p>В противном случае сообщается:
<p STYLE='margin-left:1.5cm;color:#0000b0; font-size:6.5mm'>Данные введены неправильно.
</span><BR><BR>
</UL>
<A NAME="ind"></A>  
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4>Индивидуальные задания </H4>
<p>Разработать приложение на базе технологии "клиент-сервер". <BR>
<SPAN CLASS="txt_abz">В </SPAN> задачи клиентской части входит: разработать HTML-документ,
содержащий форму, обязательными элементами которой являются:
<UL CLASS="list">                                           
<LI> три текстовых поля для ввода данных пользователя:
<UL CLASS="list2">
<LI> поле для ввода факультета и группы (name="data1");
<LI> поле для ввода имени студента (name="data2");
<LI> поле для ввода номера зачетной книжки (ЗК) и номера телефона (name="data3");
</UL>
<LI> текстовое поле для ввода литерала; 
<LI> кнопка для передачи данных на сервер.
</UL>
<P>В задачи серверной части входит: 
<UL CLASS="list"> 
<LI> принять данные из формы;
<LI> сформировать три шаблона регулярных выражений для проверки данных "data1" "data2" и "data3"
согласно колонкам "Данные1"/"Шаблон", "Данные2"/"Шаблон" и "Данные3"/"Шаблон" табл. 1. Вводимые
данные имеют постоянную и изменяемую части (последняя указана в фигурных скобках). Например, формат
"Группа:{}" означает, что должно быть введено слово "Группа: ", а затем название группы (фигурные
скобки не вводятся);
<LI> сформировать шаблон РВ для проверки правильности задания литерала согласно колонке "Литерал":
<UL CLASS="list2"> 
<LI> 1 &ndash; литерала списка, содержащего следующие элементы:<br>
1-й элемент &ndash; строка;<br>
2-й элемент &ndash; число с плавающей точкой;<br>
3-й элемент &ndash; логического типа;<br>
<LI> 2 &ndash; литерала кортежа; содержащего следующие элементы:<br>
1-й элемент &ndash; целое число;<br>
2-й элемент &ndash; список из трех строк;<br>
<LI> 3 &ndash; литерала диапазона;
<LI> 4 &ndash; литерала множества, содержащего следующие элементы:<br>
1-й элемент &ndash; кортеж из черырех целых чисел;<br>
2-й элемент &ndash; строка;<br>
<LI> 5 &ndash; литерала словаря, содержащего два элемента:<br>
ключ 1-го элемента &ndash; строка, значение &ndash; строка;<br>
ключ 2-го элемента &ndash; целое число, значение &ndash; число с плавающей точкой;
</UL>
<LI> использовать для проверки данных функции или методы согласно "Данные1"/"Метод",
"Данные2"/"Метод" и "Данные3"/"Метод" табл. 1 (для проверки колонки "Литерал" использовать метод,
который не использовался при проверках данных "data1" "data2" и "data3"):
<UL CLASS="list2"> 
<LI> 1 &ndash; функцию match() модуля re;
<LI> 2 &ndash; функцию search() модуля re;
<LI> 3 &ndash; метод match() класса RegexpObject;
<LI> 4 &ndash; метод search() класса RegexpObject;
</UL>
<LI> по результатам всех проверок передать пользоваетелю соответствующее сообщение.
</UL>
<p><table align="center" width="90%" border cellspacing="0">
<caption><p class="ba">Таблица 1 &ndash; Перечень заданий</caption>
<TR><TH ROWSPAN=2>№<TH COLSPAN=2>Данные1<TH COLSPAN=2>Данные2<TH COLSPAN=2>Данные3<TH ROWSPAN=2>
Литерал
<TR><TH>Шаблон<TH>Метод<TH>Шаблон<TH>Метод<TH>Шаблон<TH>Метод
<TR ALIGN=center><TD>1<TD>Факультет {}, гр.: {}<TD>1<TD>Фамилия И. {}<TD>2<TD>ЗК:{}<TD>3<TD>1
<TR ALIGN=center><TD>2<TD>Ф-т: {} Группа {}<TD>4<TD>Имя Фамилия {}<TD>1<TD>Номер ЗК{}<TD>2<TD>2
<TR ALIGN=center><TD>3<TD>факультет - {} груп. {}<TD>3<TD>Фамилия И.О. {}<TD>4<TD>ЗК № {}<TD>1<TD>3
<TR ALIGN=center><TD>4<TD>Группа {} ст. {}<TD>2<TD>И.О. Фамилия {}<TD>3<TD>Номер тел. {xxxxxx}<TD>4<TD>4
<TR ALIGN=center><TD>5<TD>Гр. {} студент {}<TD>1<TD>И. Фамилия {}<TD>2<TD>Тел.:{xx-xx-xx}<TD>3<TD>5
<TR ALIGN=center><TD>6<TD>груп. {} с_т {}<TD>4<TD>Фамилия И. О.{}<TD>1<TD>тел.: {xxxxxxx}<TD>2<TD>1
<TR ALIGN=center><TD>7<TD>гр.: {} с-т {}<TD>3<TD>Имя_Фамилия {}<TD>4<TD>тел. № {xxx-xx-xx}<TD>1<TD>2
<TR ALIGN=center><TD>8<TD>Студент {}, ф-т: {}<TD>2<TD>Фамилия И. {}<TD>3<TD>тел {xxxxxxxxxxx}<TD>4<TD>3
<TR ALIGN=center><TD>9<TD>Ст. {} факультет {}<TD>1<TD>Имя Фамилия {}<TD>2<TD>ЗК:{}<TD>3<TD>4
<TR ALIGN=center><TD>10<TD>Студ. {} ф_т {}<TD>4<TD>Фамилия И.О. {}<TD>1<TD>Номер ЗК{}<TD>2<TD>5
<TR ALIGN=center><TD>11<TD>С-т {}, ф т: {}<TD>3<TD>И.О. Фамилия {}<TD>4<TD>ЗК № {}<TD>1<TD>1
<TR ALIGN=center><TD>12<TD>Факультет {}, гр.: {}<TD>2<TD>И. Фамилия {}<TD>3<TD>Номер тел. {xxxxxx}<TD>4<TD>2
<TR ALIGN=center><TD>13<TD>Ф-т: {} Группа {}<TD>1<TD>Фамилия И. О.{}<TD>2<TD>Тел.:{xx-xx-xx}<TD>3<TD>3
<TR ALIGN=center><TD>14<TD>факультет - {} груп. {}<TD>4<TD>Имя_Фамилия {}<TD>1<TD>тел.: {xxxxxxx}<TD>2<TD>4
<TR ALIGN=center><TD>15<TD>Группа {} ст. {}<TD>3<TD>Фамилия И. {}<TD>4<TD>тел. № {xxx-xx-xx}<TD>1<TD>5
<TR ALIGN=center><TD>16<TD>Гр. {} студент {}<TD>2<TD>Имя Фамилия {}<TD>3<TD>тел {xxxxxxxxxxx}<TD>4<TD>1
<TR ALIGN=center><TD>17<TD>груп. {} с_т {}<TD>1<TD>Фамилия И.О. {}<TD>2<TD>ЗК:{}<TD>3<TD>2
<TR ALIGN=center><TD>18<TD>гр.: {} с-т {}<TD>4<TD>И.О. Фамилия {}<TD>1<TD>Номер ЗК{}<TD>2<TD>3
<TR ALIGN=center><TD>19<TD>Студент {}, ф-т: {}<TD>3<TD>И. Фамилия {}<TD>4<TD>ЗК № {}<TD>1<TD>4
<TR ALIGN=center><TD>20<TD>Ст. {} факультет {}<TD>2<TD>Фамилия И. О.{}<TD>3<TD>Номер тел. {xxxxxx}<TD>4<TD>5
</TABLE>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>
