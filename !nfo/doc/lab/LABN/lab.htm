<HTML>
<HEAD>
<TITLE>Лабораторная работа : Работа </TITLE>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../heads.css">
<STYLE>TH,TD{font-size:6mm; border:1 double blue}</STYLE>
</HEAD>
<BODY>
<H1> ЛАБОРАТОРНАЯ РАБОТА №</H1>
<H2> <SPAN CLASS="beg">Тема: </SPAN>на языке Python</H2>
<H2> <SPAN CLASS="beg">Цель: </SPAN>Рассмотрение способов работы с файлами</H2>
<A NAME="beg"></A>
<H3>ОГЛАВЛЕНИЕ</H3> 
<A CLASS="com" HREF="#1">1 Анализ результатов тестирования<BR>
<A CLASS="com" HREF="#3">3 Передача объектов в формате JSON<BR>
<A CLASS="com" HREF="#3.1">3.1 Использование объекта JSON<BR>
<A CLASS="com" HREF="#3.2">3.2 Использование модуля json<BR>


<A CLASS="com" HREF="#ind">Индивидуальные задания<BR>
<A NAME="1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>
<H4>1 Анализ результатов тестирования</H4>
<P>В подразделах <a href="../LAB10/lab.htm#2.1">2.1 </a>  и
<a href="../LAB10/lab.htm#2.2.3">2.2.3 </a> лаб. раб. №10 были разработаны и описаны клиентская и
серверная состовляющие приложения, осуществляющего тестирование пользователей, в первую очередь
студентов.<br>
<SPAN CLASS="txt_abz">В </SPAN>этом разделе рассмотрим новый вариант этого приложения, который
имеет следующие отличия:
<UL CLASS="list">         
<LI> в клиентской части, которая реализована в виде <a href="prim1.htm">примера №1 </a>:
<UL CLASS="list1">         
<LI> ;
<LI> ;
<LI> ;
<LI> ;
<LI> ;
<LI> ;
<LI> ;

</UL>
<P>
<A NAME="1.1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.1 </H4>
<P>
<A NAME="1.4"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.4  ***   </H4>
<P><A NAME="3"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>


<H4>3 Передача объектов в формате JSON</H4>
<P>Методы модуля <SPAN CLASS="svoj">pickle</SPAN>, рассмотренные в
<a href="lab4.htm#1.4">подразделе 1.4</a> лаб. раб. №4, позволяют осуществлять сериализацию и
десериализацию, консервацию и деконсервацию любых объектов языка Python. Однако при разработке
клиент-серверных приложений клиентская часть, использующая язык JavaScript, эти методы не
поддерживает. Поэтому для сериализации и десериализации объектов при их передаче клиенту и передачи
от клиента необходимо использовать методы JSON, которые поддерживаются языками Python (с помощью
модуля <SPAN CLASS="svoj">json</SPAN>) и JavaScript (с помощью объекта
<SPAN CLASS="svoj">JSON</SPAN>). <br>
<SPAN CLASS="txt_abz">Данные </SPAN>в формате JSON представляют собой:
<UL CLASS="list">         
<LI> JavaScript-объекты { ... };
<LI> массивы [ ... ];
<LI> строки в двойных кавычках;
<LI> числа;
<LI> логическое значение true/false;
<LI> null.
</UL>
<P>Основные методы для работы с JSON в JavaScript:
<UL CLASS="list">         
<LI> JSON.parse(str) &ndash; читает объекты из строки в формате JSON; 
<LI> JSON.stringify(obj) &ndash; превращает объекты в строку в формате JSON, используется,
когда нужно из JavaScript передать данные по сети. 
</UL>
<P>В качестве примера использования методов объекта JSON рассмотрим клиентское приложение,
основными функциями которого являются:
<UL CLASS="list">         
<LI> формирование данных пользователя в виде объекта user_data, который имеет    ;
<LI> сериализация объекта и передача с использованием технологии AJAX на сервер;
<LI> прием, десериализация данных ответа сервера и представление их на Web-странице
</UL>
<P>В качестве примера использования методов объекта 


<A NAME="3.1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">3.1 Использование объекта JSON</H4>
<P> JSON (англ. JavaScript Object Notation) &ndash; текстовый формат обмена данными, основанный на
JavaScript. формат считается языконезависимым и может использоваться практически с любым языком
программирования, например, модуль <SPAN CLASS="svoj">json</SPAN>) языка Python имеет методы,
позволяющие как представить объект в виде строки формата JSON (операция сериализации), так и
преобразоввть строку JSON в объект (операция десериализации).





<A NAME="3.2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>


<H4 CLASS="pod">3.2 Использование модуля json</H4>
<P>


Модуль <SPAN CLASS="svoj">json</SPAN> имеет следующие методы для выполнения операций сериализации и
десериализации объектов:
<UL CLASS="list">         
<LI> dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True,
cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)</SPAN> &ndash;
осуществляет сериализацию объекта <SPAN CLASS="svoj">obj</SPAN> в виде форматированого JSON-потока
в <SPAN CLASS="svoj">fp</SPAN>:
<UL CLASS="list2">         
<LI> если skipkeys = False (значение по умолчанию), то ключи словаря, не относящиеся к типам
str, unicode, int, long, float, bool и None будут вызывать исключение TypeError, иначе
(skipkeys=True) они будут проигнорированы;
<LI> если ensure_ascii = True (значение по умолчанию), то все не-ASCII символы в выводе будут
экранированы последовательностями \uXXXX, и результатом будет строка, содержащая только
ASCII-символы, иначе (>ensure_ascii = False) строки запишутся как есть;
<LI> если check_circular = True (значение по умолчанию), то циклические ссылки будут вызывать
исключение OverflowError, иначе (check_circular = False) будет осуществлена проверка циклических
ссылок;
<LI> если allow_nan = True (значение по умолчанию), то при сериализации для значения с
плавающей точкой, которое выходит за допустимые пределы, будет использоваться эквиваленты из
JavaScript (NaN, Infinity, -Infinity), иначе (allow_nan = False) при попытке сериализовать значение
плавающей точкой, выходящее за допустимые пределы, будет вызываться исключение ValueError
(nan, inf, -inf) в строгом соответствии со спецификацией JSON;
<LI> если indent является неотрицательным числом, то массивы и объекты в JSON будут выводиться
с этим уровнем отступа. Если уровень отступа равен 0, отрицательный или равен "", то будут
использоваться новые строки. Значение по умолчанию None отражает наиболее компактное представление.
Если indent &ndash; строка, то она и будет использоваться в качестве отступа;
<LI> если sort_keys = True, то ключи выводимого словаря будут отсортированы.
</ul>
<LI> json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True,
cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw) &ndash; осуществляет
сериализищию объекта obj в строку JSON-формата. Параметры имеют то же значение, что и
для метода json.dump();
<LI> json.load(fp, cls=None, object_hook=None, parse_float=None, parse_int=None,
parse_constant=None, object_pairs_hook=None, **kw) &ndash; осуществляет десериализищию JSON из fp:
<UL CLASS="list2">         
<LI> object_hook &ndash; опциональная функция, которая применяется к результату декодирования
объекта (dict). Использоваться будет значение, возвращаемое этой функцией, а не полученный словарь;
<LI> object_pairs_hook &ndash; опциональная функция, которая применяется к результату декодирования
объекта с определенной последовательностью пар ключ/значение. Будет использован результат,
возвращаемый функцией, вместо исходного словаря. Если задан так же object_hook, то приоритет
отдается object_pairs_hook;
<LI> parse_float &ndash; если определен, будет вызван для каждого значения JSON с плавающей точкой.
По умолчанию, это эквивалентно float(num_str);
<LI> parse_int &ndash; если определен, будет вызван для строки JSON с числовым значением. По
умолчанию эквивалентно int(num_str);
<LI> parse_constant &ndash; если определен, будет вызван для следующих строк: "-Infinity",
"Infinity", "NaN". Может быть использовано для возбуждения исключений при обнаружении ошибочных
чисел JSON.
</ul>
Если не удастся десериализовать JSON, будет возбуждено исключение ValueError;
<LI> json.loads(s, encoding=None, cls=None, object_hook=None, parse_float=None,
parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) &ndash; осуществлякет
десериализацию s (экземпляр str, содержащий документ JSON) в объект Python. Остальные параметры
аналогичны параметрам load().
</ul>
<p>








<A NAME="ind"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H3>Индивидуальные задания</H3>
<P>Разработать приложение на базе технологии "клиент-сервер". <BR>
<SPAN CLASS="txt_abz">В </SPAN> задачи клиентской части входит: разработать HTML-документ,
содержащий форму, обязательными элементами которой являются:
<UL CLASS="list">                                           
<LI> три текстовых поля для задания данных (желательно на киррилице), выбранных согласно
варианту в табл. 1 (поле "Данные") из следующих:
<UL CLASS="list2">
<LI> 1) Фамилия, инициалы;
<LI> 2) Наименование университета;
<LI> 3) Наименование факультета;
<LI> 4) Наименование кафедры;
<LI> 5) Наименование специальности;
<LI> 6) Курс;
<LI> 7) Наименование группы;
<LI> 8) Телефон;
<LI> 9) Моб. телефон;
<LI> 10) Электронная почта;
</UL>
 <LI> кнопка для передачи данных на сервер.
</UL>
<P>В задачи серверной части входит: 
<UL CLASS="list">                                           
<LI> принять данные из формы (для этого можно воспользовлаться функцией url_decode модуля
my_cgi или другими средствами языка Python);
<LI> записать полученные значения в текстовый файл ("*.txt", * &ndash; любое имя ) с помощью
метода, указанного в поле "Текстовый файл"/"Запись" табл. 1 (см. <A HREF="#1.3">подраздел 1.3</A>):
<UL CLASS="list2">
<LI> 1) &ndash; write();
<LI> 2) &ndash; writelines();
</UL>
<LI> прочитать данные из текстового файла с помощью метода, указанного в поле
"Текстовый файл"/"Чтение" табл. 1 (см. <A HREF="#1.3">подраздел 1.3</A>):
<UL CLASS="list2">
<LI> 1) &ndash; read();
<LI> 2) &ndash; readlines();
</UL>
<LI> сформировать словарь из трех элементов, содержащий в качестве ключей значения,
соответствующие заданию:
<UL CLASS="list2">
<LI> ФИО;
<LI> УНИВЕРСИТЕТ;
<LI> ФАКУЛЬТЕТ;
<LI> КАФЕДРА;
<LI> СПЕЦИАЛЬНОСТЬ;
<LI> КУРС;
<LI> ГРУППА;
<LI> ТЕЛЕФОН;
<LI> МОБ. ТЕЛЕФОН;
<LI> ЭЛЕКТРОННАЯ ПОЧТА,
</UL>
а в качестве значений словаря &ndash; полученные при чтении текстового файла строки;
<LI> записать словарь в двоичный файл ("*.dat") с помощью метода, указанного в поле
"Двоичный файл"/"Запись" табл. 1 (см. <A HREF="#1.5">подраздел 1.5</A>):
<UL CLASS="list2">
<LI> 1) &ndash; dump();
<LI> 2) &ndash; dumps(), write();
</UL>
<LI> прочитать словарь из двоичного файла с помощью метода, указанного в поле
"Двоичный файл"/"Чтение" табл. 1 и проверить его значение (см. <A HREF="#1.5">подраздел 1.5</A>):
<UL CLASS="list2">
<LI> 1) &ndash; load();
<LI> 2) &ndash; loads(), read().
</UL>
</UL>
<P><TABLE ALIGN=center WIDTH="60%">
<CAPTION ALIGN=right>Таблица 1 &ndash; Параметры индивидуальных заданий</CAPTION>
<TR><TH ROWSPAN=2>Номер<BR>п/п<TH ROWSPAN=2>Данные<TH COLSPAN=2>Текстовый файл<TH COLSPAN=2>Двоичный файл
<TR><TH>Запись<TH>Чтение<TH>Запись<TH>Чтение
<TR><TD ALIGN=center>1<TD ALIGN=center>1, 2, 6<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2
<TR><TD ALIGN=center>2<TD ALIGN=center>1, 2, 7<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1
<TR><TD ALIGN=center>3<TD ALIGN=center>1, 2, 8<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2
<TR><TD ALIGN=center>4<TD ALIGN=center>1, 2, 9<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1
<TR><TD ALIGN=center>5<TD ALIGN=center>1, 2, 10<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2
<TR><TD ALIGN=center>6<TD ALIGN=center>1, 3, 6<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1
<TR><TD ALIGN=center>7<TD ALIGN=center>1, 3, 7<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2
<TR><TD ALIGN=center>8<TD ALIGN=center>1, 3, 8<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1
<TR><TD ALIGN=center>9<TD ALIGN=center>1, 3, 9<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2
<TR><TD ALIGN=center>10<TD ALIGN=center>1, 3, 10<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1
<TR><TD ALIGN=center>11<TD ALIGN=center>1, 4, 6<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2
<TR><TD ALIGN=center>12<TD ALIGN=center>1, 4, 7<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1
<TR><TD ALIGN=center>13<TD ALIGN=center>1, 4, 8<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2
<TR><TD ALIGN=center>14<TD ALIGN=center>1, 4, 9<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1
<TR><TD ALIGN=center>15<TD ALIGN=center>1, 4, 10<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2
<TR><TD ALIGN=center>16<TD ALIGN=center>1, 5, 6<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1
<TR><TD ALIGN=center>17<TD ALIGN=center>1, 5, 7<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2
<TR><TD ALIGN=center>18<TD ALIGN=center>1, 5, 8<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1
<TR><TD ALIGN=center>19<TD ALIGN=center>1, 5, 9<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2
<TR><TD ALIGN=center>20<TD ALIGN=center>1, 5, 10<TD ALIGN=center>2<TD ALIGN=center>1<TD ALIGN=center>2<TD ALIGN=center>1
</TABLE>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

 Утиная типизация
 
Латентная, неявная или утиная типизация (калька с англ. Duck typing) — вид динамической типизации,
применяемой в некоторых языках программирования (Smalltalk, Objective-C, Python, Ruby, Groovy,
ColdFusion, Boo,C# ,C++ (для шаблонов)), когда границы использования объекта определяются его
текущим набором методов и свойств, в противоположность наследованию от определенного класса.
То есть считается, что объект реализует интерфейс, если он содержит все методы этого интерфейса,
независимо от связей в иерархии наследования и принадлежности к какому-либо конкретному классу. 

Название термина пошло от английского «duck test» («тест на утку»), который в оригинале звучит как:
«If it walks like a duck and quacks like a duck, it must be a duck» («Если что-то ходит, как утка,
и крякает, как утка, то это должно быть уткой»). 
Утиная типизация решает такие проблемы иерархической типизации, как: 
невозможность явно указать (путем наследования) на совместимость интерфейса со всеми настоящими и
будущими интерфейсами, с которыми он идейно совместим 
чрезмерное увеличение числа связей в иерархии типов при хотя бы частичной попытке это сделать. 

Шаблоны в Си++ реализуют статическую форму неявной типизации. Различные итераторы, например,
не обязаны наследоваться от общего класса, но могут быть использованы в единой манере,
если реализуют соответствующие методы. 

Другим близким подходом является структурные подтипы в OCaml, где типы объектов совместимы,
если совместимы сигнатуры их методов, независимо от объявленного наследования, причем все это
проверяется во время компиляции программы. 

. Полиморфизм.

Полиморфизм - это способность функции работать с аргументами разных типов.
В C++ и Java полиморфизм тесно связан с наследованием. Например, в C++, если объявлено, что
функция f принимает экземпляр класса A, то она может принимать экземпляр любого класса,
унаследованного от A. В Java это поведение расширено: за счет интерфейсов (interfaces) есть
возможность передавать в функцию экземпляры классов, не связанных "генетически" (но реализующих
один интерфейс).

В Питоне полиморфизм реализован за счет Duck Typing: любая функция может принимать объекты любого
типа, но если она попытается использовать свойства, которых у данного объекта нет, возникнет
исключение (exception) (функция может перехватить его в конструкции try...except и сделать в этом
случае что-то другое). За счет этого, например, функция, работающая с файлами, может принимать в
качестве аргумента имя файла или дескриптор открытого файла - и действовать по обстоятельствам.

Таким образом, в Питоне (как и было задумано создателями парадигмы ООП) полиморфизм и наследование
- совершенно ортогональные принципы.


7. Интроспекция.

Про этот принцип регулярно забывают, когда рассказывают об ООП на примере С++, а между тем это один
из основополагающих принципов.

Заключается он в том, что каждый объект может (во время исполнения) получить информацию об
интерфейсах и свойствах, предоставляемых любым другим объектом. Например, в разделе о типизации мы
видели, как можно получать информацию о типе переменной во время исполнения.

У каждого объекта есть некоторое количество атрибутов. Атрибуты, имена которых, начинаются с
подчеркивания, считаются приватными (private), хотя это и не влияет на область видимости - это
только соглашение. "Более приватными" являются атрибуты, имена которых начинаются с двух
подчеркиваний - снаружи они винды только как __имя-объекта__имя-атрибута__. Атрибуты, начинающиеся
с двух подчеркиваний и заканчивающиеся двумя подчеркиваниями, имеют специальный смысл.

Список всех атрибутов любого объекта можно получить с помощью встроенной функции dir:

>>> a = 1
>>> dir(a)
['__abs__', '__add__', '__and__', '__class__', '__cmp__', '__coerce__', '__delattr__', '__div__',
'__divmod__', '__doc__', '__float__', '__floordiv__', '__getattribute__', '__getnewargs__',
'__hash__', '__hex__', '__init__', '__int__', '__invert__', '__long__', '__lshift__', '__mod__',
'__mul__', '__neg__', '__new__', '__nonzero__', '__oct__', '__or__', '__pos__', '__pow__',
'__radd__', '__rand__', '__rdiv__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__',
'__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__',
'__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__str__', '__sub__',
 '__truediv__', '__xor__']

Объект, имеющий атрибут __call__, можно вызывать как функцию (собственно, функции в Питоне
отличаются от остальных объектов только наличием этого атрибута). Для проверки, можно ли
использовать объект как функцию, используется стандартная функция callable(f). Таким образом,
методы объекта - это атрибуты, которые можно вызывать.

У функций и классов есть атрибут __doc__, содержащий так называемый docstring - строку
документации. При описании функции она пишется на отдельной строке после def, при описании класса
- после class. Стандартная функция help() выдает информацию о любом объекте.

Атрибут __name__ любого объекта содержит его имя. У экземпляров классов атрибут __class__ содержит
ссылку на класс этого объекта.

Стандартная функция type() возвращает тип объекта (тип - это тоже объект).

С помощью функции isinstance(obj,cls) можно выяснить, является ли объект экземпляром данного класса
(или одного из дочерних классов). А функция issubclass(cls1,cls2) выясняет, является ли cls1
потомком cls2.

Модуль inspect, входящий в стандартную поставку Питона, содержит некоторые дополнительные
возможности интроспекции. В частности, функция inspect.getargspec(func) сообщает, сколько и каких
аргументов ожидает получить функция.


8. Динамизм.

Этот принцип не был сформулирован как один из основных для ООП, однако референсная реализация ООП
- Smalltalk - этим свойством обладает.

Речь идет о том, что свойства объекта (включая даже его тип) могут изменяться во время исполнения.
Пример:

>>> class A(object):
... pass

>>> a = A()
>>> a.x = 25 # создаем новый атрибут объекта
>>> b = A() # другой экземпляр того же класса
>>> print b.x # вызовет исключение: у объекта b нет атрибута x
>>> b.y = 30 # создаем другой атрибут
>>> dir(a)
['__class__', '__delattr__', '__dict__', '__doc__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__str__', '__weakref__', 'x']
>>> dir(b)
['__class__', '__delattr__', '__dict__', '__doc__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__str__', '__weakref__', 'y']

Можно создавать "на ходу" даже методы класса:

>>> A.method = lambda self,s: "<%s %s>" % (s,self.x)
>>> c = A()
>>> c.x = 25
>>> c.method("Text")
'<Text 25>' 


Использование метаклассов в Python 

Python* 

Некоторые средства метапрограммирования не так часто используются в ежедневной
 работе, как обычные в ООП классы или те же декораторы. Для понимания же целей
 введения подобных средств в язык требуются конкретные примеры промышленного
 применения, некоторые из которых и приведены ниже.




Введение в метаклассы


 Итак, классический ООП подразумевает наличие только классов и объектов. 
Класс -шаблон для объекта; при объявлении класса указывается вся механика 
 работы каждого конкретного «воплощения»: задаются данные, инкапсулируемые 
 в объекте, и методы для работы этими данными.


Питон расширяет классическую парадигму, и сами классы в нем тоже становятся
 равноправными объектами, которые можно менять, присваивать переменной и
 передавать в функции. Но если класс — объект, то какому классу он соответствует?
По умолчанию этот класс (метакласс) называется type.

От метакласса можно наследоваться, получая новый метакласс, который, в свою
 очередь, можно использовать при определении новых классов. Таким образом,
появляется новое «измерение» наследования, добавляющееся к иерархии наследования
 классов: метакласс -> класс -> объект.


Простой пример


 Предположим, нас утомило задание атрибутов в контрукторе __init__(self, *args,
 **kwargs). Хотелось бы ускорить этот процесс таким образом, чтобы была
 возможность задавать атрибуты прямо при создании объекта класса. С обычным
 классом такое не пройдет:

  >>>class Man(object):
  >>>    pass
  >>>me = Man(height = 180, weight = 80)
  Traceback (most recent call last):
  File "<stdin>", line 20, in <module>
      TypeError: object.__new__() takes no parameters



Объект конструируется вызовом класса оператором "()". Создадим наследованием от
type метакласс, переопределяющий этот оператор:


  >>>class AttributeInitType(type):
  >>>    def __call__(self, *args, **kwargs):
  >>>        """ Вызов класса создает новый объект. """
  >>>        # Перво-наперво создадим сам объект...
  >>>        obj = type.__call__(self, *args)
  >>>        # ...и добавим ему переданные в вызове аргументы в качестве атрибутов.
  >>>        for name in kwargs:
  >>>            setattr(obj, name, kwargs[name])
  >>>        # вернем готовый объект
  >>>        return obj


Теперь создадим класс, использующий новый метакласс:

  >>>class Man(object):
  >>>    __metaclass__ = AttributeInitType


Вуаля:

  >>>me = Man(height = 180, weigth = 80)
  >>>print me.height
  180

www.cafepy.com/article/python_types_and_objects/

8. Итератор

Итераторы хороши там, где списки не подходят в силу того, что занимают много памяти, а итератор возвращает его конкретное значение. В классе нужно определить два стандартных метода — __iter__ и next. Метод __iter__ будет возвращать объект через метод next:

class Reverse:
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def next(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]

>>> for char in Reverse('12345'):
>>>   print char
5
4
3
2
1

Итератор можно сконвертировать в список:

>>> rvr = list(Reverse('12345'))
>>> rvr
['5', '4', '3', '2', '1']



14. Sequence

Последовательность реализуется с помощью методов __getitem__, __setitem__. В данном примере класс
MySequence возвращает по индексу элемент последовательности неопределенной длины, представляющей
собой арифметическую прогрессию вида: 1 3 5 7 ... Здесь нельзя применить стандартные методы
 __del__ , __len__:

class MySequence:
  def __init__(self, start=0, step=1):
      self.start = start                         
      self.step = step                           
      self.changed = {}                          
  def __getitem__(self, key):
      return self.start + key*self.step    
  def __setitem__(self, key, value):
      self.changed[key] = value                  
   
>>> s = MySequence(1,2)
>>> s[0]
1
>>> s[1]
3
>>> s[100]
201
3. Экземпляры классов в качестве последовательностей 

Экземпляры классов можно использовать для эмуляции последовательностей. Для такой реализации есть встроенные методы:

__len__ — возвращает длину последовательности;

__getitem__ — получение элемента по индексу или ключу;

__setitem__ — присваивание элемента с данным ключом или индексом;

__delitem__ — удаление элемента с данным ключом или индексом;

__getslice__ — возвращает вложенную последовательность;

__setslice__ — заменяет вложенную последовательность;

__delslice__ — удаляет вложенную последовательность;

__contains__ — реализует оператор in.

2. Экземпляры классов и специальные методы 

Экземпляр (инстанс) класса возвращается при вызове объекта-класса. Объект у класса может быть один, экземпляров (или инстансов) — несколько. Экземпляры имеют следующие атрибуты:

__dict__ — словарь атрибутов класса, можно изменять этот словарь напрямую;

__class__ — объект-класс, экземпляром которого является данный инстанс;

__init__ — конструктор. Если в базовом классе есть конструктор, конструктор производного класса должен вызвать его;

__del__ — деструктор. Если в базовом классе есть деструкор, деструктор производного класса должен вызвать его;

__cmp__ — вызывается для всех операций сравнения;

__hash__ — возвращает хеш-значение объекта, равное 32-битному числу;

__getattr__ — возвращает атрибут, недоступный обычным способом;

__setattr__ — присваивает значение атрибуту;

__delattr__ — удаляет атрибут;

__call__ — срабатывает при вызове экземпляра класса.

 Утиная типизация
 
Латентная, неявная или утиная типизация (калька с англ. Duck typing) — вид динамической типизации,
применяемой в некоторых языках программирования (Smalltalk, Objective-C, Python, Ruby, Groovy,
ColdFusion, Boo,C# ,C++ (для шаблонов)), когда границы использования объекта определяются его
текущим набором методов и свойств, в противоположность наследованию от определенного класса.
То есть считается, что объект реализует интерфейс, если он содержит все методы этого интерфейса,
независимо от связей в иерархии наследования и принадлежности к какому-либо конкретному классу. 

Название термина пошло от английского «duck test» («тест на утку»), который в оригинале звучит как:
«If it walks like a duck and quacks like a duck, it must be a duck» («Если что-то ходит, как утка,
и крякает, как утка, то это должно быть уткой»). 
Утиная типизация решает такие проблемы иерархической типизации, как: 
невозможность явно указать (путем наследования) на совместимость интерфейса со всеми настоящими и
будущими интерфейсами, с которыми он идейно совместим 
чрезмерное увеличение числа связей в иерархии типов при хотя бы частичной попытке это сделать. 

Шаблоны в Си++ реализуют статическую форму неявной типизации. Различные итераторы, например,
не обязаны наследоваться от общего класса, но могут быть использованы в единой манере,
если реализуют соответствующие методы. 

Другим близким подходом является структурные подтипы в OCaml, где типы объектов совместимы,
если совместимы сигнатуры их методов, независимо от объявленного наследования, причем все это
проверяется во время компиляции программы. 

. Полиморфизм.

Полиморфизм - это способность функции работать с аргументами разных типов.
В C++ и Java полиморфизм тесно связан с наследованием. Например, в C++, если объявлено, что
функция f принимает экземпляр класса A, то она может принимать экземпляр любого класса,
унаследованного от A. В Java это поведение расширено: за счет интерфейсов (interfaces) есть
возможность передавать в функцию экземпляры классов, не связанных "генетически" (но реализующих
один интерфейс).

В Питоне полиморфизм реализован за счет Duck Typing: любая функция может принимать объекты любого
типа, но если она попытается использовать свойства, которых у данного объекта нет, возникнет
исключение (exception) (функция может перехватить его в конструкции try...except и сделать в этом
случае что-то другое). За счет этого, например, функция, работающая с файлами, может принимать в
качестве аргумента имя файла или дескриптор открытого файла - и действовать по обстоятельствам.

Таким образом, в Питоне (как и было задумано создателями парадигмы ООП) полиморфизм и наследование
- совершенно ортогональные принципы.


7. Интроспекция.

Про этот принцип регулярно забывают, когда рассказывают об ООП на примере С++, а между тем это один
из основополагающих принципов.

Заключается он в том, что каждый объект может (во время исполнения) получить информацию об
интерфейсах и свойствах, предоставляемых любым другим объектом. Например, в разделе о типизации мы
видели, как можно получать информацию о типе переменной во время исполнения.

У каждого объекта есть некоторое количество атрибутов. Атрибуты, имена которых, начинаются с
подчеркивания, считаются приватными (private), хотя это и не влияет на область видимости - это
только соглашение. "Более приватными" являются атрибуты, имена которых начинаются с двух
подчеркиваний - снаружи они винды только как __имя-объекта__имя-атрибута__. Атрибуты, начинающиеся
с двух подчеркиваний и заканчивающиеся двумя подчеркиваниями, имеют специальный смысл.

Список всех атрибутов любого объекта можно получить с помощью встроенной функции dir:

>>> a = 1
>>> dir(a)
['__abs__', '__add__', '__and__', '__class__', '__cmp__', '__coerce__', '__delattr__', '__div__',
'__divmod__', '__doc__', '__float__', '__floordiv__', '__getattribute__', '__getnewargs__',
'__hash__', '__hex__', '__init__', '__int__', '__invert__', '__long__', '__lshift__', '__mod__',
'__mul__', '__neg__', '__new__', '__nonzero__', '__oct__', '__or__', '__pos__', '__pow__',
'__radd__', '__rand__', '__rdiv__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__',
'__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__',
'__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__str__', '__sub__',
 '__truediv__', '__xor__']

Объект, имеющий атрибут __call__, можно вызывать как функцию (собственно, функции в Питоне
отличаются от остальных объектов только наличием этого атрибута). Для проверки, можно ли
использовать объект как функцию, используется стандартная функция callable(f). Таким образом,
методы объекта - это атрибуты, которые можно вызывать.

У функций и классов есть атрибут __doc__, содержащий так называемый docstring - строку
документации. При описании функции она пишется на отдельной строке после def, при описании класса
- после class. Стандартная функция help() выдает информацию о любом объекте.

Атрибут __name__ любого объекта содержит его имя. У экземпляров классов атрибут __class__ содержит
ссылку на класс этого объекта.

Стандартная функция type() возвращает тип объекта (тип - это тоже объект).

С помощью функции isinstance(obj,cls) можно выяснить, является ли объект экземпляром данного класса
(или одного из дочерних классов). А функция issubclass(cls1,cls2) выясняет, является ли cls1
потомком cls2.

Модуль inspect, входящий в стандартную поставку Питона, содержит некоторые дополнительные
возможности интроспекции. В частности, функция inspect.getargspec(func) сообщает, сколько и каких
аргументов ожидает получить функция.


8. Динамизм.

Этот принцип не был сформулирован как один из основных для ООП, однако референсная реализация ООП
- Smalltalk - этим свойством обладает.

Речь идет о том, что свойства объекта (включая даже его тип) могут изменяться во время исполнения.
Пример:

>>> class A(object):
... pass

>>> a = A()
>>> a.x = 25 # создаем новый атрибут объекта
>>> b = A() # другой экземпляр того же класса
>>> print b.x # вызовет исключение: у объекта b нет атрибута x
>>> b.y = 30 # создаем другой атрибут
>>> dir(a)
['__class__', '__delattr__', '__dict__', '__doc__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__str__', '__weakref__', 'x']
>>> dir(b)
['__class__', '__delattr__', '__dict__', '__doc__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__str__', '__weakref__', 'y']

Можно создавать "на ходу" даже методы класса:

>>> A.method = lambda self,s: "<%s %s>" % (s,self.x)
>>> c = A()
>>> c.x = 25
>>> c.method("Text")
'<Text 25>' 


Использование метаклассов в Python 

Python* 

Некоторые средства метапрограммирования не так часто используются в ежедневной
 работе, как обычные в ООП классы или те же декораторы. Для понимания же целей
 введения подобных средств в язык требуются конкретные примеры промышленного
 применения, некоторые из которых и приведены ниже.




Введение в метаклассы


 Итак, классический ООП подразумевает наличие только классов и объектов. 
Класс -шаблон для объекта; при объявлении класса указывается вся механика 
 работы каждого конкретного «воплощения»: задаются данные, инкапсулируемые 
 в объекте, и методы для работы этими данными.


Питон расширяет классическую парадигму, и сами классы в нем тоже становятся
 равноправными объектами, которые можно менять, присваивать переменной и
 передавать в функции. Но если класс — объект, то какому классу он соответствует?
По умолчанию этот класс (метакласс) называется type.

От метакласса можно наследоваться, получая новый метакласс, который, в свою
 очередь, можно использовать при определении новых классов. Таким образом,
появляется новое «измерение» наследования, добавляющееся к иерархии наследования
 классов: метакласс -> класс -> объект.


Простой пример


 Предположим, нас утомило задание атрибутов в контрукторе __init__(self, *args,
 **kwargs). Хотелось бы ускорить этот процесс таким образом, чтобы была
 возможность задавать атрибуты прямо при создании объекта класса. С обычным
 классом такое не пройдет:

  >>>class Man(object):
  >>>    pass
  >>>me = Man(height = 180, weight = 80)
  Traceback (most recent call last):
  File "<stdin>", line 20, in <module>
      TypeError: object.__new__() takes no parameters



Объект конструируется вызовом класса оператором "()". Создадим наследованием от
type метакласс, переопределяющий этот оператор:


  >>>class AttributeInitType(type):
  >>>    def __call__(self, *args, **kwargs):
  >>>        """ Вызов класса создает новый объект. """
  >>>        # Перво-наперво создадим сам объект...
  >>>        obj = type.__call__(self, *args)
  >>>        # ...и добавим ему переданные в вызове аргументы в качестве атрибутов.
  >>>        for name in kwargs:
  >>>            setattr(obj, name, kwargs[name])
  >>>        # вернем готовый объект
  >>>        return obj


Теперь создадим класс, использующий новый метакласс:

  >>>class Man(object):
  >>>    __metaclass__ = AttributeInitType


Вуаля:

  >>>me = Man(height = 180, weigth = 80)
  >>>print me.height
  180

www.cafepy.com/article/python_types_and_objects/
