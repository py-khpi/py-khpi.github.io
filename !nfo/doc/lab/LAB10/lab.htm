<!doctype html>
<HTML lang="ru">                                     
<HEAD>
<meta charset="utf-8">
<TITLE>Лабораторная работа 10: Использование технологии AJAX при разработке клиент-серверного
приложения</TITLE>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../heads.css">
<STYLE>TH,TD { font-size:5.5mm;border:1 double blue; } </STYLE>
</HEAD>
<BODY>
<H1> ЛАБОРАТОРНАЯ РАБОТА №10</H1>
<H2> <SPAN CLASS="beg">Тема: </SPAN>Использование технологии AJAX при разработке клиент-серверного
приложения</H2>
<H2> <SPAN CLASS="beg">Цель: </SPAN> Рассмотрение особенностей работы серверного приложения,
использующего технологию AJAX</H2>
<A NAME="beg"></A>
<H3>ОГЛАВЛЕНИЕ</H3> 
<A CLASS="com" HREF="#1">1 Использование технологии AJAX<BR>
<A CLASS="com" HREF="#1.1">1.1 Объект XMLHttpRequest<BR>
<A CLASS="com" HREF="#1.2">1.2 Чтение текста из локального сервера<BR>
<A CLASS="com1" HREF="#1.3">1.3 Обеспечение безопасности и конфиденциальности данных в сети<BR>
<A CLASS="com" HREF="#2">2 Разработка приложения с использованием технологии AJAX<BR>
<A CLASS="com" HREF="#2.1">2.1 Разработка клиентской части<BR>
<A CLASS="com" HREF="#2.2">2.2 Разработка серверной части<BR>
<A CLASS="com1" HREF="#2.2">2.2.1 Разработка тестов<BR>
<A CLASS="com1" HREF="#2.2.2">2.2.2 Разработка тестирующей программы<BR>
<A CLASS="com1" HREF="#2.2.3">2.2.3 Передача результатов тестирования <BR>
<A CLASS="com" HREF="#prim1">Пример №1 <BR>
<A CLASS="com" HREF="#prim1a">Пример №1a <BR>
<A CLASS="com" HREF="#prim1b">Пример №1b <BR>
<A CLASS="com" HREF="#prim1c">Пример №1c <BR>
<A CLASS="com" HREF="#prim2">Пример №2 <BR>
<A CLASS="com" HREF="#ind">Индивидуальные задания<BR>
<A NAME="1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4>1 Использование технологии AJAX</H4>
<P>AJAX (от англ. Asynchronous Javascript and XML) &ndash; асинхронный JavaScript и XML)
представляет собой технологию, позволяющую при необходимости в фоновом режиме (не прерывая работы
пользователя и незаметно для него) выполнять запросы к серверу и получать дополнительные данные для обновления
отдельных частей Web-страницы, тем самым исключая необходимость повторной загрузки страницы.
Например, выполнять на стороне сервера проверку правильности заполнения данных пользоваетелем по
мере их ввода.<BR>                         
<SPAN CLASS="txt_abz">Без </SPAN>использования технологии AJAX для решения этой задачи имеются
такие возможности:
<UL CLASS="list">
<LI> выполнять проверку на стороне сервера, но в этом случае необходимо формировать новую
Web-страниц, что увеличивает загрузку сети и увеличивает время ожидания клиента;
<LI> выполнять проверку на стороне клиента, но при этом зачастую необходимо хранить большой
объем информации на компьютере клиента.
</UL>
<P>В целом использование AJAX имеет следующие преимущества:
<UL CLASS="list">
<LI> Экономия трафика: 
<UL CLASS="list2">
<LI>Использование AJAX позволяет значительно сократить трафик при работе с Web-приложением
благодаря тому, что часто вместо загрузки всей страницы достаточно загрузить только изменившуюся
часть, как правило, довольно небольшую;
</UL>
<LI> Уменьшение нагрузки на сервер:
<UL CLASS="list2">
<LI>AJAX позволяет несколько снизить нагрузку на сервер. К примеру, на странице работы с почтой,
когда отмечаются прочитанные письма, серверу достаточно внести изменения в базу данных и отправить
клиентскому скрипту сообщение об успешном выполнении операции без необходимости повторно создавать
страницу и передавать ее клиенту;
</UL>
<LI> Ускорение реакции интерфейса: 
<UL CLASS="list2">
<LI>Поскольку нужно загрузить только изменившуюся часть Web-страницы, пользователь видит результат
своих действий быстрее.
</UL>
</UL>
<P>Недостатки использования AJAX:
<UL CLASS="list">
<LI> Отсутствие интеграции со стандартными инструментами браузера: 
<UL CLASS="list2">
<LI>Динамически создаваемые страницы не регистрируются браузером в истории посещения страниц,
поэтому не работает кнопка «Назад», предоставляющая пользователям возможность вернуться к
просмотренным ранее страницам, но существуют скрипты, которые могут решить эту проблему;
<LI>Другим недостатком изменения содержимого страницы при постоянном URL является невозможность
сохранить закладки на желаемый материал (это можно решить с помощью History.pushState).
</UL>
<LI> Динамически загружаемое содержимое недоступно поисковикам (если не проверять запрос,
обычный он или XMLHttpRequest): 
<UL CLASS="list2">
<LI>Поисковые машины не могут выполнять JavaScript, поэтому разработчики должны позаботиться об
альтернативных способах доступа к содержимому сайта.                
</UL>
<LI> Старые методы учета статистики сайтов становятся неактуальными: 
<UL CLASS="list2">
<LI>Многие сервисы статистики ведут учет просмотров новых страниц сайта, для сайтов, страницы
которых широко используют AJAX, такая статистика теряет актуальность.
</UL>
<LI> Усложнение проекта: 
<UL CLASS="list2">
<LI> Перераспределяется логика обработки данных &ndash; происходит выделение и частичный перенос на
сторону клиента процессов первичного форматирования данных. Это усложняет контроль целостности
форматов и типов;
<LI> Конечный эффект технологии может быть нивелирован необоснованным ростом затрат на кодирование
и управление проектом, а также риском снижения доступности сервиса для конечных пользователей.
</UL>
<LI> Требуется включенный в браузере JavaScript: 
<UL CLASS="list2">
<LI> JavaScript может быть выключен из соображений безопасности;
<LI> AJAX-страницы труднодоступны неполнофункциональным браузерам, роботам и веб-архивам.
</UL>
</UL>
<P>Для применения AJAX необходимы следующие компоненты:<BR>
<UL CLASS="list">
<LI> JavaScript (основной компонент);
<LI> объект XMLHttpRequest;
<LI> серверные технологии (например, PHP или Python).
</UL>
<P>Первоначально технологию AJAX разработала фирма Microsoft в виде объекта ActiveX для браузера
Internet Explorer. Затем программисты проекта Mozilla создали объект XMLHttpRequest с (почти)
идентичными API, который после доработки стандартизирован организацией W3C и в настоящее время
поддерживается всеми ведущими браузерами. Последнее обновление действующего стандарта
XMLHttpRequest (Living Standart) произошло 25.11.2015 года.<BR>                         
<SPAN CLASS="txt_abz">Технология </SPAN>AJAX стала популярной в 2005 году в связи с появлением
сервиса Google Suggest (англ. suggest &ndash; предлагать) &ndash; технологии автозаполнения строки
поискового запроса на основе общей статистики самых популярных запросов. Таким образом, запрос
пользователя предсказывается после ввода уже нескольких символов, и в выпадающем списке
предлагается выбор готовых слов и словосочетаний. 
<A NAME="1.1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.1 Объект XMLHttpRequest</H4>
<P>Объект <SPAN CLASS="svoj">XMLHttpRequest</SPAN> дает возможность отправлять асинхронные
HTTP-запросы из кода JavaScript серверу, принимать от него ответы и обновлять отдельные части
Web-страницы, не прерывая работу пользователя. Имеет следующие методы:
<UL CLASS="list">
<LI> abort() &ndash; отменяет любые сетевые действия;
<LI> getAllResponseHeaders() &ndash; возвращает все HTTP-заголовки ответа сервера в виде
строки (кроме Set-Cookie);
<LI> getResponseHeader(header) &ndash; возвращает указанный HTTP-заголовок ответа сервера в
виде строки (кроме Set-Cookie);
<LI> open(method, URL [, async = true [, username = null [, password = null]]]) &ndash;
инициализирует параметры запроса, где:
<UL CLASS="list2">
<LI> method &ndash; один из методов обмена данными с сервером: наиболее часто используются GET и
POST, но разрешены также методы HEAD, TRACE, PUT или DELETE;
<LI> URL &ndash; абсолютный или относительный URL-адрес сервера (кроме http:// протокола могут быть
также использованы протоколы ftp:// и file://);
<LI> async (необязательнлый параметр) &ndash; значение true означает асинхронный режим работы с
сервером: скрипт, послав запрос серверу, продолжает свою работу (значение по умолчанию), значение
false означает синхронный режим работы с сервером: скрипт, послав запрос серверу, приостанавливает
свою работу, ожидая ответа от сервера;
<LI> username (необязательнлый параметр) &ndash; имя пользователя для аутентификации, если параметр
равен null или "" и сайт требует аутентификации, то появляется окно login;
<LI> password (необязательнлый параметр) &ndash; пароль пользователя для аутентификации, если равен
Null или "", то игнорируется;
</UL>
<LI> overrideMimeType(mime) &ndash; задает для заголовка ответа Content-Type значение mime;
<LI> send([data=null]) &ndash; выполняет запрос (аргумент игнорируется для методов GET или HEAD);
<LI> setRequestHeader(name, value) &ndash; добавляет заголовок запроса name со значением
value, например:<BR><BR>
<SPAN CLASS="html">
xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');</SPAN>
</UL>
<p class="ba">и свойства:
<UL CLASS="list">
<LI> onreadystatechange &ndash; используется для регистрации обработчика события
readystatechange, возникающим в асинхронном режиме при изменении состояния запроса;
<LI> readyState &ndash; возвращает состояние запроса, значение может быть задано числом или
константой:
<UL CLASS="list2">
<LI> 0 (UNSENT) &ndash; объект создан;
<LI> 1 (OPENED) &ndash;  метод open() успешно вызван. В течение этого состояния с помощью метода
setRequestHeader() могут быть установлены HTTP-заголовки запроса и выполнен с использованием
метода send() запрос;
<LI> 2 (HEADERS_RECEIVED) &ndash; все перенаправления (англ. redirect) сделаны (если они есть) и
получены HTTP-заголовки ответа;
<LI> 3 (LOADING) &ndash; получено тело (содержимое) ответа;
<LI> 4 (DONE) &ndash; обмен данными завершен или произошла ошибкм.
</UL>
<LI> response &ndash; возвращает тело ответа (тип ответа указан в свойстве responseType);
<LI> responseText &ndash; возвращает ответ сервера в виде строки;
<LI> responseType [ = value ] &ndash; устанавливает или возвращает тип ответа (по умолчанию
&ndash; пустая спрока):
<UL CLASS="list2">
<LI> "arraybuffer";
<LI> "blob";
<LI> "document" (игнорируется если значением JavaScript global environment является worker
environment);
<LI> "json";
<LI> "text";
</UL>
<LI> responseXML &ndash; возвращает ответ сервера в формате XML;
<LI> status &ndash; возвращает HTTP-код состояния запроса (запросы по протоколам ftp:// и
file:// не возвращают статуса, поэтому нормальным для них является status=0);
<LI> statusText &ndash; возвращает сообщение о состоянии запроса;
<LI> timeout &ndash; указывает или возвращает время в миллисекндах. Если значение не равно 0
&ndash; проверяет, не вышло ли время ожиданич ответа за указанное значение. Если вышло &ndash;
вызывается исключение (значение по умолчанию 0);
<LI> upload &ndash; возвращает ассоциированный объект XMLHttpRequestUpload, который может быть
использован при передаче файла на сервер для получения информации о передаче; 
<LI> withCredentials &ndash; указывает, надо ли передавать учетные данные пользователя
(credentials).
</UL>
<P> Во время функционирования объекта <SPAN CLASS="svoj">XMLHttpRequest</SPAN> при изменении его
состояния (которое указывается в свойстве <SPAN CLASS="svoj">readyState</SPAN>) возникает событие
<SPAN CLASS="svoj">onreadystatechange</SPAN>, которое может быть использовано для определения
текущего состояния объекта.  <BR>                         
<SPAN CLASS="txt_abz">Кроме </SPAN>того современная спецификация предусматривает следующие события
оазвития (progress events), т.е. возникающие по ходу обработки запроса:
<UL CLASS="list">
<LI> loadstart &ndash; запрос начат;
<LI> progress  &ndash; браузер получил очередной пакет данных, можно прочитать текущие полученные
данные в responseText;
<LI> abort &ndash; запрос был отменен вызовом меторда abort();
<LI> error &ndash; произошла ошибка;
<LI> load &ndash; запрос был успешно (без ошибок) завершен;
<LI> timeout &ndash; запрос был прекращен по таймауту;
<LI> loadend &ndash; запрос был завершен (успешно или нет).
</UL>
<P>Для создания экземпляров объекта <SPAN CLASS="svoj">XMLHttpRequest</SPAN> при использовании
браузеров, которые его поддерживают &ndash; все бразеры, за исключением IE5 и IE6, необходимо
использовать конструктор <SPAN CLASS="svoj">XMLHttpRequest()</SPAN>, а для браузеров Internet
Explorer версий 5 и 6 &ndash; конструктор
<SPAN CLASS="svoj">ActiveXObject("Microsoft.XMLHttp")</SPAN>. Поэтому для создания объекта
<SPAN CLASS="svoj">xhr</SPAN>, который имеет все методы и свойства объекта
<SPAN CLASS="svoj">XMLHttpRequest</SPAN>, можно предложить следующий код:<BR><BR>
<SPAN CLASS="html"> var xhr; </SPAN><BR>
<SPAN CLASS="html"> if(window.XMLHttpRequest) { </SPAN><BR>
<SPAN CLASS="html_par"> xhr=new XMLHttpRequest(); </SPAN><BR>
<SPAN CLASS="html"> } else { </SPAN><BR>
<SPAN CLASS="html_par"> xhr=new ActiveXObject("Microsoft.XMLHTTP"); </SPAN><BR>
<SPAN CLASS="html"> } </SPAN>
<P> Создание объекта <SPAN CLASS="svoj">xhr</SPAN>, использование его методов, свойств и
обработчиков событий приведено в примерах <A HREF=#prim1> №1</A>, <A HREF=#prim1a> №1a</A> и
<A HREF=#prim1a> №1b</A>, в которых осуществлен прием текстовых данных из локального сервера, а
также в <A HREF=#prim2>примере №2</A></SPAN>, в котором в процессе тестирования выполнена передача
серверу имени тестируемого, прием тестов от сервера и передача ответов серверу.
<a id="1.2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.2 Чтение текста из локального сервера</H4>
<P>В <A HREF=#prim1>примере №1</A> показано чтение текстового файла из локального сервера с помощью
технологии AJAX. Особенностью этого примера является то, что в нем, помимо решения основной задачи
&ndash; получения текстовых данных из сервера и вывода их на текущей странице, решаются также
задачи получения и вывода дополнительной информации учебного и отладочного характера:
<A id="prim1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<P><A CLASS="out" HREF="prim1.htm">Пример 1</A><BR><BR>
<SPAN CLASS="html">&lt;!DOCTYPE html> </SPAN><BR>
<SPAN CLASS="html">&lt;html> </SPAN><BR>
<SPAN CLASS="html">&lt;head> </SPAN><BR>
<SPAN CLASS="html">&lt;title> Чтение текста из локального сервера с помощью технологии AJAX&lt;/title></SPAN><BR>
<SPAN CLASS="html">&lt;/head> </SPAN><BR>
<SPAN CLASS="html">&lt;body> </SPAN><BR>
<SPAN CLASS="html">&lt;div id="myDiv" /> </SPAN><BR>
<SPAN CLASS="html">&lt;script> </SPAN><BR>
<SPAN CLASS="html_par"> var myDiv=document.getElementById("myDiv");</SPAN><BR>
<SPAN CLASS="html_par"> var xhr; </SPAN><BR>
<SPAN CLASS="html_par"> if(window.XMLHttpRequest) { </SPAN><BR>
<SPAN CLASS="html_par1"> xhr=new XMLHttpRequest(); </SPAN><BR>
<SPAN CLASS="html_par"> } else { // </SPAN>
<SPAN CLASS="html_com">IE5,IE6 </SPAN><BR>
<SPAN CLASS="html_par1"> xhr=new ActiveXObject("Microsoft.XMLHTTP");</SPAN><BR>
<SPAN CLASS="html_par"> }</SPAN><BR>
<SPAN CLASS="html_par"> myDiv.innerHTML="Состояние 0 (UNSENT): Объект xhr создан; &lt;br>";
</SPAN><BR>
<SPAN CLASS="html_par"> xhr.open("GET", "http://zykov/data.txt?r="+Math.random(),true); </SPAN><BR>
<SPAN CLASS="html_par"> xhr.onreadystatechange=handleStateChange;</SPAN><BR>
<SPAN CLASS="html_par"> xhr.send() ;</SPAN><BR>
<SPAN CLASS="html_par"> myDiv.innerHTML+="Скрипт продолжает работать&lt;br>"; </SPAN><BR>
<SPAN CLASS="html_par"> function handleStateChange() { </SPAN><BR>
<SPAN CLASS="html_par1"> switch(this.readyState) { </SPAN><BR>
<SPAN CLASS="html_par2"> case 1: myDiv.innerHTML+= </SPAN><BR>
<SPAN CLASS="html_par3">"Состояние 1 (OPEND): Метод open() успешно вызван; &lt;br>";break; 
</SPAN><BR>
<SPAN CLASS="html_par2"> case 2: myDiv.innerHTML+= </SPAN><BR>
<SPAN CLASS="html_par3">"Состояние 2 (HEADERS RECEIVED): получены HTTP-заголовки ответа :&lt;br>"+ 
</SPAN><BR>
<SPAN CLASS="html_par3"> "Content-Type: &ltspan style='color:blue'>"+
this.getResponseHeader("Content-Type")+</SPAN><BR>
<SPAN CLASS="html_par4"> "&lt/span&lt;br>"+ </SPAN><BR>
<SPAN CLASS="html_par3"> "Date: &ltspan style='color:blue'>"+ this.getResponseHeader("Date")+
"&lt/span> "+</SPAN><BR>
<SPAN CLASS="html_par4">this.statusText+ "&lt;br>"; break; </SPAN><BR>
<SPAN CLASS="html_par2"> case 3: myDiv.innerHTML+= </SPAN><BR>
<SPAN CLASS="html_par3"> "Состояние 3 (LOADING): тело ответа получено; "+this.statusText+"&lt;br>";
break; </SPAN><BR>
<SPAN CLASS="html_par2"> case 4: { myDiv.innerHTML+= </SPAN><BR>
<SPAN CLASS="html_par3">"Состояние 4 (DONE) передача данных завершена "+ this.statusText+"&lt;br>";
</SPAN><BR>
<SPAN CLASS="html_par3"> if(this.status==200) { </SPAN><BR>
<SPAN CLASS="html_par4"> try { </SPAN><BR>
<SPAN CLASS="html_par5"> resp=this.responseText; </SPAN><BR>
<SPAN CLASS="html_par5"> myDiv.innerHTML+="Сервер передал: </SPAN><BR>
<SPAN CLASS="html_par6">&lt;span style='color:blue; font-size:5.5mm'>"+resp+"&lt;/span>&lt;br>"; 
</SPAN><BR>
<SPAN CLASS="html_par4"> } </SPAN><BR>
<SPAN CLASS="html_par4"> catch(e) { </SPAN><BR> 
<SPAN CLASS="html_par5"> myDiv.innerHTML+="Ошибка чтения ответа: "+e.name.toString()+"  "+</SPAN><BR>
<SPAN CLASS="html_par6">e.message; </SPAN><BR>
<SPAN CLASS="html_par4"> }  </SPAN><BR>
<SPAN CLASS="html_par3"> } else myDiv.innerHTML+="Ошибка получения данных: статус: "+this.status;
</SPAN><BR>
<SPAN CLASS="html_par2"> } </SPAN><BR>
<SPAN CLASS="html_par1"> } </SPAN><BR>
<SPAN CLASS="html_par"> } </SPAN><BR>
<SPAN CLASS="html">&lt;/script> </SPAN><BR>   
<SPAN CLASS="html">&lt;/body> </SPAN><BR>
<SPAN CLASS="html">&lt;/html> </SPAN>
<p> При запуске <A HREF=#prim1>примера №1</A> выполняются следующие действия:
<UL CLASS="list">
<LI> создается объект xhr &ndash; экземпляр объекта XMLHttpRequest;
<LI> создается ссылка myDiv на элемент &lt;div />, который используется для вывода данных в окно
браузера; 
<LI> в объект myDiv заносятся данные о начальном состоянии запроса к серверу;
<LI> с помощью метода open() объекта xhr задаются следующие значения параметров соединения с
сервером:
<UL CLASS="list2">
<LI> метод &ndash; GET;
<LI> адрес файла на сервере &ndash; "http://zykov/data.txt";
<LI> значение флага асинхронного режима &ndash; true;
</UL>
<LI> в качестве обработчика события onreadystatechange указывается функция handleStateChange;
<LI> с помощью метода send() объекта xhr посылается запрос на сервер. 
</UL>
<P>Отметим, что использование в методе open() аргумента URL, имеющего значениее
<SPAN CLASS="svoj">"http://zykov/data.txt?r="+Math.random()</SPAN>, позволяет передать на сервер
не только url-адрес текстового файла, но и случайное число, генерируемое методом
<SPAN CLASS="svoj">random()</SPAN> объекта <SPAN CLASS="svoj">Math</SPAN>. Поскольку при этом
каждый вызов будет отличаться от предыдущего, браузер будет передавать клиенту данные не из
своего кэша, а непостредственно из сервера. Этот режим можно использовать, например, при отладке
скрипта для разных значений данных на сервере.<BR>                         
<SPAN CLASS="txt_abz">При </SPAN>каждом изменении состояния запроса (свойство readyState), начиная
с состояния 1, происходит вызов функции handleStateChange(), которая осуществляет такие действия:
<UL CLASS="list">
<LI> вывод данных о текущем состоянии запроса (для состояний 1,2,3 и 4 &ndash; для пояснения и
отладки):
<UL CLASS="list2">
<LI> номер и наименование состояния;
<LI> краткую характеристику состояния;
<LI> значение статуса ответа сервера (свойство statusText) &ndash; для тех состояний для которых
браузер передает этот статус;
</UL>
<LI> в состоянии 2 (HEADERS RECEIVED) получает и выведит в окно браузера значения следующих
HTTP-заголовков ответа:
<UL CLASS="list2">                            
<LI> Content-Type;
<LI> Date;
</UL>
<LI> в состоянии 4 (DONE), в котором завершается обмен данными с сервером, проверяет статус ответа
сервера. Если он равен 200, т.е. обмен завершен успешно:
<UL CLASS="list2">
<LI> проверяет с помощью оператора try/catch правильность прочитанных их сервера с помощью свойства
responseText данных;
<LI> Если данные прочитаны правильно &ndash; заносит их в элемент myDiv для вывода в окно браузера;
<LI> в противном случае &ndash; выводит сообщение "Ошибка чтения ответа" и свойства объекта Error;
</UL> 
<LI> если же в состоянии 4 статус ответа сервера не равен 200 &ndash; выводит сообщение "Ошибка
получения данных" и статус ответа.
</UL>
<p>При выполнении <A HREF=#prim1>примера №1</A> в окно браузера были выведены следующие результаты
его работы:
<P class="ba"><SPAN style="margin-left:2cm; font-size:5.0mm; ">
Состояние 0 (UNSENT): Объект xhr создан;  </span><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; ">
Состояние 1 (OPEND): Метод open() успешно вызван;  </SPAN><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; ">
Скрипт продолжает работать </SPAN><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; ">
Состояние 2 (HEADERS RECEIVED): получены HTTP-заголовки ответа : </SPAN><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; ">
Content-Type: <span style='color:blue'>text/plain</span></SPAN><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; ">
Date: <span style='color:blue'>Fri, 11 Dec 2015 15:33:34 GMT</span> OK </SPAN><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; ">
Состояние 3 (LOADING): тело ответа получено; OK </SPAN><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; ">
Состояние 4 (DONE) передача данных завершена OK </SPAN><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; ">
Сервер передал: <span style='color:blue;font-size:6.0mm'>Привет, клиент!</span> </SPAN><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; "> </SPAN><BR>
<p> В случае выполнения <A HREF=#prim1>примера №1</A> в синхронном режиме (async=false) были
получены следующие результаты его работы:
<P class="ba"><SPAN style="margin-left:2cm; font-size:5.0mm; ">
Состояние 0 (UNSENT): Объект xhr создан;  </span><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; ">
Состояние 4 (DONE) передача данных завершена OK </SPAN><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; ">
Сервер передал: <span style='color:blue;font-size:6.0mm'>Привет, клиент!</span> </SPAN><BR>
<SPAN style="margin-left:2cm; font-size:5.0mm; ">
Скрипт продолжает работать </SPAN><BR>
<p>Эти результаты работы в синхронном режиме показывают следующее:
<UL CLASS="list">                            
<LI> событие readystatechange не вызывается при изменении состояния запроса;
<LI> скрипт после отправления запроса на сервер ожидает получения данных из сервера и только после
этого продолжает свою работу.
</UL>
<p> Поэтому синхронный режим в дальнейшем использоваться не будет. <BR> 
<SPAN CLASS="txt_abz">В </SPAN><A HREF=#prim1a>примере №1a</A> решается та же задача, что и в
<A HREF=#prim1>примере №1</A> &ndash; получение данных из текстового файла сервера. Но в нем, в
отличие от <A HREF=#prim1>примера №1</A> не задействованы средства пояснения и отладки &ndash; это
пример уже отлаженного скрипта, поэтому объем его кода значительно меньше:
<A id="prim1a"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<P><A CLASS="out" HREF="prim1a.htm">Пример 1a</A><BR><BR>
<SPAN CLASS="html">&lt;!DOCTYPE html> </SPAN><BR>
<SPAN CLASS="html">&lt;html> </SPAN><BR>
<SPAN CLASS="html">&lt;head> </SPAN><BR>
<SPAN CLASS="html">&lt;title> Чтение текста из локального сервера&lt;/title></SPAN><BR>
<SPAN CLASS="html">&lt;/head> </SPAN><BR>
<SPAN CLASS="html">&lt;body> </SPAN><BR>
<SPAN CLASS="html">&lt;div id="myDiv" /> </SPAN><BR>
<SPAN CLASS="html">&lt;script> </SPAN><BR>
<SPAN CLASS="html_par"> var myDiv=document.getElementById("myDiv"); </SPAN><BR>
<SPAN CLASS="html_par"> var xhr=new XMLHttpRequest(); </SPAN><BR>
<SPAN CLASS="html_par"> xhr.open("get", "http://zykov/data.txt?r="+Math.random()); </SPAN><BR>
<SPAN CLASS="html_par"> xhr.onreadystatechange=handleReadyState; </SPAN><BR>
<SPAN CLASS="html_par"> xhr.send(); </SPAN><BR>
<SPAN CLASS="html_par"> function handleReadyState() { </SPAN><BR>
<SPAN CLASS="html_par1"> if(this.readyState==this.DONE&&this.status==200) { </SPAN><BR>
<SPAN CLASS="html_par2"> myDiv.innerHTML+="&lt;span style='color:blue; font-size:5.5mm'>"+
this.responseText+</SPAN><BR>
<SPAN CLASS="html_par3">"&lt;/span>"; </SPAN><BR>
<SPAN CLASS="html_par1"> } </SPAN><BR>
<SPAN CLASS="html_par"> } </SPAN><BR>
<SPAN CLASS="html">&lt;/script> </SPAN><BR>   
<SPAN CLASS="html">&lt;/body> </SPAN><BR>
<SPAN CLASS="html">&lt;/html> </SPAN>
<p>Результат работы <A HREF=#prim1a>примера №1a</A>: 
<p class="ba" style="margin-left:2cm; color:blue; font-size:6.0mm; "> Привет, клиент! </SPAN>
<p> <A HREF=#prim1b>Пример №1b</A> отличается от <A HREF=#prim1a>примера №1a</A> тем, что в нем
использованы возможности, указанные в новой спецификации объекта
<SPAN CLASS="svoj">XMLHttpRequest</SPAN> (см. <A HREF=#1.1>подраздел 1.1</A>), а именно:
<UL CLASS="list">
<LI> события продвижения (вместо события readystatechange):
<UL CLASS="list2">
<LI> load &ndash; возникает, когда передача данных сервером успешно завершена; 
<LI> error &ndash; возникает в случает возникновения ошибки при передачи данных из сервера;
</UL>
<LI> свойство response (вместо свойства responseText</SPAN>), которое возвращает данные, полученные
от сервера, в виде строки, если значение свойства responseType не задано (его значение по
умолчанию &ndash; строка).
</UL>
<A id="prim1b"></A><BR>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<P><A CLASS="out" HREF="prim1b.htm">Пример 1b</A><BR><BR>
<SPAN CLASS="html">&lt;!DOCTYPE html> </SPAN><BR>
<SPAN CLASS="html">&lt;html> </SPAN><BR>
<SPAN CLASS="html">&lt;head> </SPAN><BR>
<SPAN CLASS="html">&lt;title> Чтение текста из локального сервера&lt;/title></SPAN><BR>
<SPAN CLASS="html">&lt;/head> </SPAN><BR>
<SPAN CLASS="html">&lt;body> </SPAN><BR>
<SPAN CLASS="html">&lt;div id="myDiv" /> </SPAN><BR>
<SPAN CLASS="html">&lt;script> </SPAN><BR>
<SPAN CLASS="html_par"> var myDiv=document.getElementById("myDiv"); </SPAN><BR>
<SPAN CLASS="html_par"> var xhr=new XMLHttpRequest(); </SPAN><BR>
<SPAN CLASS="html_par"> xhr.open("get", "http://zykov/data.txt?r="+Math.random()); </SPAN><BR>
<SPAN CLASS="html_par"> xhr.onerror=function(e) { </SPAN><BR> 
<SPAN CLASS="html_par1"> myDiv.innerHTML+=" Error"; </SPAN><BR> 
<SPAN CLASS="html_par"> } </SPAN><BR>
<SPAN CLASS="html_par"> xhr.onload=function() { </SPAN><BR>
<SPAN CLASS="html_par1"> myDiv.innerHTML+="&lt;span style='color:blue; font-size:5.5mm'>"+
this.response+ </SPAN><BR>
<SPAN CLASS="html_par2">"&lt;/span>";  </SPAN><BR>
<SPAN CLASS="html_par"> } </SPAN><BR>
<SPAN CLASS="html_par"> xhr.send(); </SPAN><BR>
<SPAN CLASS="html">&lt;/script> </SPAN><BR>   
<SPAN CLASS="html">&lt;/body> </SPAN><BR>
<SPAN CLASS="html">&lt;/html> </SPAN>
<p>Результат работы <A HREF=#prim1b>примера №1b</A> такой же, как результат работы
<A HREF=#prim1a>примера №1a</A>: 
<p class="ba" style="margin-left:2cm; color:blue; font-size:6.0mm; "> Привет, клиент! </SPAN>
<p>Отметим, что в <A HREF=#prim1b>примере №1b</A> вместо события <SPAN CLASS="svoj">load</SPAN>
можно использовать событие <SPAN CLASS="svoj">progress</SPAN> и получать данные по частям
(пакетам). Но в данном случае данные из сервера имеют небольшой размер и результат работы будет
такой же, как и при использовании события <SPAN CLASS="svoj">load</SPAN>: 
<p class="ba" style="margin-left:2cm; color:blue; font-size:6.0mm; "> Привет, клиент! </SPAN>
<p> Необходимо сказать, что приведенные результаты работы примеров <A HREF=#prim1> №1</A>,
<A HREF=#prim1a> №1a</A> и <A HREF=#prim1b> №1b</A> были получены только при использовании браузера
Internet Explorer. На остальных ведущих браузерах примеры <A HREF=#prim1> №1</A> и
<A HREF=#prim1a> №1a</A> не дадут никакого разультата, а <A HREF=#prim1b>пример №1b</A> даст
сообщение "Error". Это связано с несколько различной трактовкой браузерами политики "одинакового
произхождения" ("the same origin"), которая была введена для междоменных передач данных с целью
повышения их безопастности, и которую поддерживает технология AJAX (см. <a href="#1.3">
подраздел 1.3</a>). 
<A NAME="1.3"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.3 Обеспечение безопасности и конфиденциальности данных в сети</H4>
<P>С целью обеспечения безопасности и конфиденциальности данных при их обмене в сети были
разработаны правила, названные "политикой одинакового источника" (same-origin policy). Две
Web-страницы имеют одинаковый источник, если:
<UL CLASS="list">
<LI> имеют одинаковые схемы (протоколы); 
<LI> имеют одинаковые порты (если указаны);
<LI> имеют одинаковые хосты (hosts).
</UL>
<P>Пусть, например, Web-страница имеет следующий URL: http://www.company.com/dir/page.html. Тогда
результаты проверки на одинаковый источник следующих страниц дадут такие результаты:
<UL CLASS="list">
<LI> http://www.company.com/dir2/other.html &ndash; "+"; 
<LI> http://www.company.com/dir/inner/another.html &ndash; "+";
<LI> https://www.company.com/secure.html &ndash; "-" (другой протокол);
<LI> http://www.company.com:81/dir/etc.html &ndash; "-" (другой порт);
<LI> http://news.company.com/dir/other.html &ndash; "-" (другой хост).
</UL>
<P CLASS="ba">Знак "+" означает, что проверяемая страница имеет одинаковый источник с исходной
страницей, а знак "-" &ndash;  разный.<BR>
<SPAN CLASS="txt_abz">Политика </SPAN> same-origin предусматривает, что две Web-страницы могут
обмениваться данными без ограничений только при условии, что они имеют одинаковый источник.
Отметим, что браузер Internet Explorer имеет два исключения из этого правила:
<UL CLASS="list">
<LI> если оба домена находятся в "зоне доверия" (highly trusted zone), то к этим доменам
правило одинакового происхождения не применяется; 
<LI> порты не включаются в компоненты происхождения.
</UL>
<P>Поскольку объект <SPAN CLASS="svoj">XMLHttpRequest()</SPAN> подчиняется политике одинакового
источника, то при доступе к данным локального сервера просходит сравнение происхождения
страницы, вызвавшей запрос, и сервера, отправляющего ответ браузеру. И хотя в примерах
<A HREF=#prim1> №1</A>, <A HREF=#prim1a> №1a</A> и <A HREF=#prim1b> №1b</A> скрипты, формирующие 
запросы к серверу, и сам сервер распололагаются на одном и том же компьютере, считается, что они
имеют разный источник, поскольку используют разные схемы. Поэтому браузер Internet Explorer, за
счет исключения из общего правила, разрешил чтение данных из локального сервера, а браузеры,
подчиняющиеся всем правилам политики одинакового источника, &ndash; нет.<BR>
<SPAN CLASS="txt_abz">Выходом </SPAN>из создавшегося положения является использование предложенного
группой W3C механизма CORS (Cross-Origin Resource Sharing), т.е. совместное использование
ресурсов при обмене, осуществляемом страницами разного источника (кросс-доменными страницами),
который состоит из набора HTTP-заголовков и указывает Web-серверу путь, разрешающий доступ к
требуемым ресурсам для определенных сайтов. Если сервер в своем ответе указывает HTTP-заголовок
Access-Control-Allow-Origin со значениями "*", то это означает, что он разрешает доступ к данным
сервера всем сайтам. Другое значение указывает имя сайта, для которого разрешен доступ. Отметим,
что разрешение действует только для методов GET и POST, на методы PUT и DELETE оно не
распространяется. <BR>
<SPAN CLASS="txt_abz">Таким </SPAN>образом, чтобы данные на сервере стали доступны объекту
<SPAN CLASS="svoj">XMLHttpRequest()</SPAN>, необходимо, чтобы сервер в своем ответе наряду с
данными передал HTTP-заголовок "Access-Control-Allow-Origin: *". Однако это можно сделать, только
применив серверное приложение, например, следующий скрипт на языке Python<BR><BR>
<SPAN CLASS="html">#!c:/ . . . /python.exe </SPAN><BR>
<SPAN CLASS="html">print("Access-Control-Allow-Origin: *") </SPAN><BR>
<SPAN CLASS="html">print() </SPAN><BR>
<SPAN CLASS="html">print("Hello, client!"),</SPAN><BR>
<P CLASS="ba">который расположен по адресу "http://zykov/PYTHON/data.py" и выполняет следующие
действия:
<UL CLASS="list">
<LI> вызывает интерпретатор языка Python (первая строка);
<LI> создает и передает клиенту ответ сервера (последующие три строки с использованием
функции print()):
<UL CLASS="list2">
<LI> первая формирует HTTP-заголовок ответа;
<LI> вторая &ndash; пустую строку для отделения HTTP-заголовка от тела ответа;
<LI> третья &ndash; данные, передаваемые клиенту.
</UL>
</UL>
<P>Если в <A HREF=#prim1a>примере №1b</A> изменить URL-адрес запрашиваемого ресурса с
http://zykov/data.txt?r=' + Math.random() на http://zykov/PYTHON/data.py?r=' + Math.random(),
то при запуске созданного таким образом <A HREF=#prim1c>примера №1c</A>
<A id="prim1c"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<P><A CLASS="out" HREF="prim1c.htm">Пример 1c</A><BR><BR>
<SPAN CLASS="html">&lt;!DOCTYPE html> </SPAN><BR>
<SPAN CLASS="html">&lt;html> </SPAN><BR>
<SPAN CLASS="html">&lt;head> </SPAN><BR>
<SPAN CLASS="html">&lt;title> Чтение текста из локального сервера&lt;/title></SPAN><BR>
<SPAN CLASS="html">&lt;/head> </SPAN><BR>
<SPAN CLASS="html">&lt;body> </SPAN><BR>
<SPAN CLASS="html">&lt;div id="myDiv" /> </SPAN><BR>
<SPAN CLASS="html">&lt;script> </SPAN><BR>
<SPAN CLASS="html_par"> var myDiv=document.getElementById("myDiv"); </SPAN><BR>
<SPAN CLASS="html_par"> var xhr=new XMLHttpRequest(); </SPAN><BR>
<SPAN CLASS="html_par"> xhr.open("get", "http://zykov/PYTHON/data.py?r="+Math.random()); </SPAN><BR>
<SPAN CLASS="html_par"> xhr.onerror=function(e) { </SPAN><BR> 
<SPAN CLASS="html_par1"> myDiv.innerHTML+=" Error"; </SPAN><BR> 
<SPAN CLASS="html_par"> } </SPAN><BR>
<SPAN CLASS="html_par"> xhr.onload=function() { </SPAN><BR>
<SPAN CLASS="html_par1"> myDiv.innerHTML+="&lt;span style='color:blue; font-size:5.5mm'>"+
this.response+ </SPAN><BR>
<SPAN CLASS="html_par2">"&lt;/span>";  </SPAN><BR>
<SPAN CLASS="html_par"> } </SPAN><BR>
<SPAN CLASS="html_par"> xhr.send(); </SPAN><BR>
<SPAN CLASS="html">&lt;/script> </SPAN><BR>   
<SPAN CLASS="html">&lt;/body> </SPAN><BR>
<SPAN CLASS="html">&lt;/html> </SPAN>
<p>получим корректный результат:
<p class="ba" style="margin-left:2cm; color:blue; font-size:6.0mm; "> Привет, клиент! </p>
<p class="ba">
уже на всех популярных браузерах: Internet Explorer, Chrome, Firefox, Opera и Safari. Такие же
результаты будут получены и при изменении метода GET на метод POST.
<A NAME="2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4>2 Разработка приложения с использованием технологии AJAX</H4>
<P>В качестве примера разработки приложения, использующего в рамках технологии "клиент-сервер"
средства AJAX, выбрана задача тестирования пользователя на стороне клиента. Взаимодействие между
клиентом и сервером осуществляется следующим образом.<BR>
<SPAN CLASS="txt_abz">Тестирование </SPAN>начинается с того, что клиент запрашивает имя
пользователя и передает его серверу. Сервер последовательно тест за тестом отправляет клиенту
сформированные и хранящиеся на сервере тесты. Клиент визуализирует тесты на Web-странице,
принимает по каждому тесту ответ пользователя и передает его серверу. После окончания тестирования
сервер передает клиенту результаты тестирования. Все обмены данными между сервером и клиентом происходят в рамках
технологии AJAX, т.е. без формирования новых Web-страниц.<BR>
<SPAN CLASS="txt_abz">Далее </SPAN>мы рассмотрим более подробно работу клиенткой части приложения
и работу ее серверной части.
<A NAME="2.1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">2.1 Разработка клиентской части</H4>
<P>Клиентская часть приложения реализована в виде примера №2, при выполнении которого создается
Web-страница, содержащая заголовок ("Тестирование"), кнопки "СТАРТ" и  "ОТВЕТ", а также поле для
помещения тестов (тег &lt;div ... />. CSS свойства кнопок "Начать тестирование" и "Указать ответ"
задаются из файла <SPAN CLASS="svoj">"lab.css"</SPAN>, который подклюяается к HTML-файлу данного
примера (см. <a href="../LAB7/lab.htm#2">раздел 2</a> лаб. раб. №7). 
<A NAME="prim2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<P><A CLASS="out" HREF="prim2.htm">Пример 2</A><BR><BR>
<SPAN CLASS="html">&lt;html&gt;</SPAN><BR>
<SPAN CLASS="html">&lt;head&gt;</SPAN><BR>
<SPAN CLASS="html">&lt;title&gtТестирование пользователя с использованием технологии AJAX
&lt;/title></SPAN><BR>
<SPAN CLASS="html">&lt;link rel=stylesheet href="../lab.css"></SPAN><BR> 
<SPAN CLASS="html">&lt;script&gt;</SPAN><BR>
<SPAN CLASS="html_par">var name='', answer='',</SPAN>
<SPAN CLASS="html_com"> //Фамилия и ответ пользователя</SPAN><BR>
<SPAN CLASS="html_par">xhr=new XMLHttpRequest();</SPAN><BR>
<SPAN CLASS="html_par">function subm1() { </SPAN><BR>
<SPAN CLASS="html_par1"> name=prompt('Введите фамилию',''); </SPAN><BR>
<SPAN CLASS="html_par1"> if(name) { </SPAN><BR>
<SPAN CLASS="html_par2"> xhr.open('GET','http://zykov/PYTHON/testing.py?r='+
                        Math.random()+'&name='+name); </SPAN><BR>
<SPAN CLASS="html_par2"> xhr.send(null);</SPAN><BR>
<SPAN CLASS="html_par1"> } </SPAN><BR>
<SPAN CLASS="html_par1"> else alert("Имя не введено"); </SPAN><BR>
<SPAN CLASS="html_par">}</SPAN><BR>
<SPAN CLASS="html_par">function subm2() { </SPAN><BR>
<SPAN CLASS="html_par1"> answer=prompt('Введите ответ в виде трех двоичных цифр','');</SPAN><BR>
<SPAN CLASS="html_par1"> if (answer) { </SPAN><BR>
<SPAN CLASS="html_par2"> xhr.open('GET','http://zykov/PYTHON/testing.py?r='+ 
                         Math.random()+'&answer='+answer); </SPAN><BR>
<SPAN CLASS="html_par2"> xhr.send(null); </SPAN><BR>
<SPAN CLASS="html_par1"> } </SPAN><BR>
<SPAN CLASS="html_par1"> else alert("Ответ не указан") </SPAN><BR>
<SPAN CLASS="html_par"> } </SPAN><BR>
<SPAN CLASS="html_par"> xhr.onerror=function(e) { </SPAN><BR> 
<SPAN CLASS="html_par1"> myDiv.innerHTML+=" Ошибка получения данных из сервера"; </SPAN><BR>
<SPAN CLASS="html_par"> } </SPAN><BR>
<SPAN CLASS="html_par"> xhr.onload=function() { </SPAN><BR>
<SPAN CLASS="html_par1"> myDiv=document.getElementById("div"); </SPAN><BR>
<SPAN CLASS="html_par1"> resp=this.responseText; </SPAN><BR>                          
<SPAN CLASS="html_par1"> myDiv.innerHTML="&lt;p>&lt;span style='color:blue;font-size:5.5mm'>"+resp+
"&lt;/span>";</SPAN><BR>
<SPAN CLASS="html_par"> }</SPAN><BR>
<SPAN CLASS="html"> }</SPAN><BR>
<SPAN CLASS="html">&lt;/script&gt;<BR>
<SPAN CLASS="html">&lt;/head&gt;<BR>
<SPAN CLASS="html">&lt;body><BR>
<SPAN CLASS="html">&lt;h1>Тестирование&lt;/h1><BR>
<SPAN CLASS="html">&lt;button onclick="subm1()">Начать &lt;br>тестирование&lt;/button>&nbsp<BR>
<SPAN CLASS="html">&lt;button onclick="subm2()">Указать &lt;br>ответ&lt;/button><BR>
<SPAN CLASS="html">&lt;div id="div" /><BR>
<SPAN CLASS="html">&lt;/body><BR>
<SPAN CLASS="html">&lt;/htnl><BR>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>
<P> <A HREF=#prim2>Пример №2</A> начинает свою работу с создания объекта
<SPAN CLASS="svoj">xhr</SPAN>, реализующего механизм AJAX. Это делается с помощью конструктора
<SPAN CLASS="svoj">XMLHttpRequest()</SPAN> без использования альтернативного варианта в виде
конструктора <SPAN CLASS="svoj">ActiveXObject("Microsoft.XMLHTTP")</SPAN>, как это было выполнено в
<A HREF=#prim1>примере №1</A>. Кроме того, с целью уменьшения объема скрипта не были использованы
средства отладки и диагностики. При необходимости все эти программные стредства могут быть
добавлены в код.<BR>
<SPAN CLASS="txt_abz">Процесс </SPAN>тестирования начинается с нажатия пользователем
(тестируемым) кнопки "Начать тестирование". При этом по событию
<SPAN CLASS="svoj">onclick</SPAN> происходит вызов функции <SPAN CLASS="svoj">submit1()</SPAN>,
которая:
<UL CLASS="list">                                           
<LI> с помощью метода prompt() объекта window принимает имя тестируемого пользователя и заносит его
в переменную name (в данной работе имя пользователя задается в виде его фамилии и инициалов,
например, Петров А.А.);
<LI> если имя не задано &ndash; предлагает пользователю его ввести;
<LI> если имя задано:
<UL CLASS="list2">                                           
<LI> с помощью метода open() объекта xhr формирует запрос к серверному скрипту по адресу
"http:// . . . /Python/testing.py" с указанием метода "GET" и передаваемых клиентом данных
&ndash; случайного числа, генерируемого методом random() объекта Math, и имени пользователя.
Случайное число при передаче данных на сервер необходимо для того, чтобы браузер всегда
получал ответ не из кэш-памяти, а непосредственно от сервера;
<LI> с помощью метода send() объекта xhr передает серверу указанные данные;
</UL>
</UL>
<P>Затем с помощью обработчика события <SPAN CLASS="svoj">onerror()</SPAN> объекта
<SPAN CLASS="svoj">xhr </SPAN> проверяется, не возникла ли ошибка при обмене данными между клиентом
и сервером. Если ошибка возникла &ndash; клиенту выдается соответствующее сообщение и тестирование
завершается. <BR>
<SPAN CLASS="txt_abz">При </SPAN>успешном завершении приема данных от сервера &ndash; по событию
<SPAN CLASS="svoj">onload </SPAN> объекта <SPAN CLASS="svoj">xhr </SPAN> производится считывание
данных, переданных сервером, в переменную <SPAN CLASS="svoj">resp</SPAN> с последующим отображением
ее значения на данной Web-странице с помощью тега &lt;div>.<BR>
<SPAN CLASS="txt_abz">Сервер </SPAN>в соответствии с работой серверного приложения (см. описание
программы <SPAN CLASS="svoj">testing.py</SPAN> <A HREF="#2.2.2">в подразделе 2.2.2</A>) передает
клиенту данные двух типов:
<UL CLASS="list">                                           
<LI> если тестирование не завершено &ndash; очередной тест (разработку тестов см. в
<A HREF="#2.2"> подразделе 2.2.1</A>);
<LI> после завершения тестирования &ndash; его результаты. 
</UL>
<P>Когда сервер передает тест, пользователь формирует ответ на этот тест в виде трех двоичных цифр
( см. <A HREF="#2.2"> подраздел 2.2.1</A>) и нажимает кнопку "Указать ответ". При этом по событию
<SPAN CLASS="svoj">onclick</SPAN> происходит вызов функции <SPAN CLASS="svoj">submit2()</SPAN>,
которая:
<UL CLASS="list">                                           
<LI> с помощью метода prompt() принимает от тестируемого ответ и заносит его в переменную answer;
<LI> если ответ не задан &ndash; предлагает пользователю его ввести;
<LI> в случае успешного занесения ответа, выполняются те же действия, что и при выполнении функции
submit1() &ndash; только вместо передачи имени (переменная name), передается ответ тестируемого
(переменная answer).
</UL>
<P> Если сервер передал вместо очередного теста результаты тестирования, то это обозначает, что
процесс тестирования завершен. Чтобы выполнить тестирование нового пользователя или
протестировать текущего пользователя еще раз, необходимо нажать кнопку "Начать тестирование".
<A NAME="2.2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>
<H4 CLASS="pod">2.2 Разработка серверной части</H4>

<H4 CLASS="pod1">2.2.1 Разработка тестов</H4>
<P>Тесты предлагается формировать в виде строки, которая содержит:
<UL CLASS="list">                                           
<LI> заголовок теста, указывающий номер теста (n) в виде "<i>Тест №n.</i>";
<LI> основную часть, состоящую из утверждения (или вопроса) по заданной тематике и трех
вариантов ответа, каждый из которых имеет номер (1, 2, 3) и задается с новой строки;
<LI> эталонное значение, отделенное от основной части точкой с запятой.
</UL>
<P>Имеется несколько подходов к формированию вариантов ответа и эталонного значения. Например,
из всех вариантов ответа только один вариант сделать правильным, а остальные &ndash; неправильными.
Но при таком подходе и при трех вариантах ответа полуается слишком большая вероятность угадывания
правильного ответа (1/3). Чтобы не увеличивать число вариантов ответа предлагается такой подход к
формированию тестов. <BR>
<SPAN CLASS="txt_abz">Каждый </SPAN>из трех вариантов ответа может быть как правильным, так и
неправильным. Если вариант правильный, он имеет значение 1, если нет &ndash; 0). Эталонное значение
теста формируется из значений вариантов ответа в виде трех двоичных цифр: самой левой цифре
соответствует значение первого варианта ответа, средней цифре &ndash; значение второго варианта
ответа и правой цифре &ndash; значение третьего варианта ответа. Например, эталонное значение 101
означает, что первый и третий варианты ответа были правильными, а второй вариант &ndash; нет. При
таком подходе вероятность угадать правильный ответ уменьшается до 1/8.<BR>
<SPAN CLASS="txt_abz">Для </SPAN>формирования тестов и записи их на диск разработана программа
<SPAN CLASS="svoj">form_test.py</SPAN>, которая не является серверным приложением и может
запускаться на выполнение из среды разработки Python:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#ff8000">import</SPAN>
<SPAN STYLE="font-size:7mm; color:black">pickle</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">TESTS=[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'Тест №1. Изменяемые типы данных:'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">\</SPAN><BR>
<SPAN STYLE="margin-left:7.4cm; font-size:7mm; color:green">
'&lt;br>1. кортеж&lt;br> 2. словарь &lt;br>3. строка;010'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN><BR>
<SPAN STYLE="margin-left:4.4cm; font-size:7mm; color:green">
'Тест №2. Выполняется только чтение из текстового файла:'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">\</SPAN><BR>
<SPAN STYLE="margin-left:7.4cm; font-size:7mm; color:green">
'&lt;br>1. mode=\'\' &lt;br>2. mode=\'r\' &lt;br>3. mode=\'r+\';110'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN><BR>
<SPAN STYLE="margin-left:4.4cm; font-size:7mm; color:green">
'Тест №3. Выполняется удаление существующего файла:'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">\</SPAN><BR>
<SPAN STYLE="margin-left:7.4cm; font-size:7mm; color:green">
'&lt;br>1. mode=\'w\' &lt;br>2. mode=\'w+\' &lt;br>3. mode=\'a\';100'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN><BR>
<SPAN STYLE="margin-left:4.4cm; font-size:7mm; color:green">
'Тест №4.В качестве ключа словаря могут быть использованы:'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">\</SPAN><BR>
<SPAN STYLE="margin-left:7.4cm; font-size:7mm; color:green">
'&lt;br>1. кортежи &lt;br>2. числа &lt;br>3. строки;111'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN><BR>
<SPAN STYLE="margin-left:4.4cm; font-size:7mm; color:green">
'Тест №5. Модуль mod имеет фукцию func(). При каком подключении модуля'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">\</SPAN><BR>
<SPAN STYLE="margin-left:7.4cm; font-size:7mm; color:green">
'фукция func() будет непосредсвтвенно доступна программе?'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">\</SPAN><BR>
<SPAN STYLE="margin-left:7.4cm; font-size:7mm; color:green">
'&lt;br>1. import mod &lt;br>2. from mod import func &lt;br>3. from mod import *;011'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">f=</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">open</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'tests.dat'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'wb'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">pickle.dump(TESTS,f)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">f.close()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"It/s done"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Таким </SPAN>образом в соответствии с выше описанным подходом сформировано
пять тестов в виде списка строк <SPAN CLASS="svoj">TESTS</SPAN>, который с помощью метода
<SPAN CLASS="svoj">dump()</SPAN> модуля <SPAN CLASS="svoj">pickle</SPAN> в сериализованном виде
записан в двоичный файл <SPAN CLASS="svoj">tests.dat</SPAN> и в последствии может быть использован
для получения тестов (см. <a href="#2.2">подраздел 2.2.1</a>).
<A NAME="2.2.2">
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod1">2.2.2 Разработка тестирующей программы</H4>
<P>В качестве примера серверного приложения, осуществляющего AJAX-взаимодействие с клиентским
приложением (см. <A HREF=#prim2>пример №2 </A> в <A HREF=#2.1>подразделе 2.1</A>) разработана
программа <SPAN CLASS="svoj">testing.py</SPAN>:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:red">#!c:/ . . . /python.exe </SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"Access-Control-Allow-Origin: *"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#FF8000">import</SPAN>
<SPAN STYLE="font-size:7mm; color:black">cgi, cgitb, random, pickle</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#FF8000">from </SPAN>
<SPAN STYLE="font-size:7mm; color:black">my_mod </SPAN>
<SPAN STYLE="font-size:7mm; color:#FF8000">import </SPAN>
<SPAN STYLE="font-size:7mm; color:black">write_results, D</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">cgitb.enable()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#ff8000">def</SPAN>
<SPAN STYLE="font-size:7mm; color:blue">get_test</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(file_name):</SPAN>
<SPAN STYLE="margin-left:4.7cm; font-size:7mm; color:red">
# Функция считывает из файла file_name тесты </SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">f=</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">open</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(file_name,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'rb'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN>
<SPAN STYLE="margin-left:2.5cm; font-size:7mm; color:red"> # и возвращает один из них</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">test_list=pickle.load(f)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">f.close()</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">test=random.choice(test_list)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">test_list.remove(test)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">f=</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">open</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'cur_tests.dat'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, </SPAN>
<SPAN STYLE="font-size:7mm; color:green">'wb'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">pickle.dump(test_list,f)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">f.close()</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#ff8000">return</SPAN>
<SPAN STYLE="font-size:7mm; color:black">test</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">max_test=3</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">data=cgi.parse()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#ff8000">if </SPAN>
<SPAN STYLE="font-size:7mm; color:green">'name' </SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">in </SPAN>
<SPAN STYLE="font-size:7mm; color:black">data:</SPAN><BR>
<SPAN STYLE="margin-left:8.7cm; font-size:7mm; color:red">
# От клиента получено имя тестируемого </SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">test=get_test(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'tests.dat' </SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(D, test.split( </SPAN>
<SPAN STYLE="font-size:7mm; color:green">';' </SPAN>
<SPAN STYLE="font-size:7mm; color:black">)[0]) </SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">user_dict={</SPAN>
<SPAN STYLE="margin-left:7.0cm; font-size:7mm; color:red">
# Словарь данных тестируемого содержит:</SPAN><BR>
<SPAN STYLE="margin-left:7.2cm; font-size:7mm; color:green">'name' </SPAN>
<SPAN STYLE="font-size:7mm; color:black">:data[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'name' </SPAN>
<SPAN STYLE="font-size:7mm; color:black">][0],</SPAN>
<SPAN STYLE="margin-left:1.0cm; font-size:7mm; color:red"> # имя</SPAN><BR>
<SPAN STYLE="margin-left:7.2cm; font-size:7mm; color:green">'number_test'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:1,</SPAN>
<SPAN STYLE="margin-left:3.3cm; font-size:7mm; color:red"> # порядковй номер очередного теста</SPAN><BR>
<SPAN STYLE="margin-left:7.2cm; font-size:7mm; color:green">'tests'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:[test],</SPAN>
<SPAN STYLE="margin-left:4.4cm; font-size:7mm; color:red"> # список переданных тестов</SPAN><BR>
<SPAN STYLE="margin-left:7.2cm; font-size:7mm; color:green">'answers'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:[],</SPAN>
<SPAN STYLE="margin-left:4.4cm; font-size:7mm; color:red"> # список ответов пользователя</SPAN><BR>
<SPAN STYLE="margin-left:7.2cm; font-size:7mm; color:green">'points'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:0 }</SPAN>
<SPAN STYLE="margin-left:4.7cm; font-size:7mm; color:red"> # число набранных баллов</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">f=</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">open </SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'user.dat'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'wb'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">pickle.dump(user_dict,f)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">f.close()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#ff8000">if </SPAN>
<SPAN STYLE="font-size:7mm; color:green">'answer'</SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">in </SPAN>
<SPAN STYLE="font-size:7mm; color:black">data:</SPAN><BR>
<SPAN STYLE="margin-left:8.7cm; font-size:7mm; color:red">
# От клиента получен ответ тестируемого </SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">f=</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">open </SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'user.dat'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'rb'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">user_dict=pickle.load(f)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">user_dict[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'answers'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]+=[data[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'answer'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">][0]]</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">tests=user_dict[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'tests'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">etalon=tests[</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">len</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(tests)-1:][0].split(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">';'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)[1]</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#ff8000">if </SPAN>
<SPAN STYLE="font-size:7mm; color:black">data[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'answer'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">][0]==etalon: user_dict[ </SPAN>
<SPAN STYLE="font-size:7mm; color:green">'points'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]+=1</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#ff8000">if </SPAN>
<SPAN STYLE="font-size:7mm; color:black">user_dict[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'number_test'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]&lt'max_test: </SPAN><BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:black">test=get_test(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'cur_tests.dat'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(D, test.split( </SPAN>
<SPAN STYLE="font-size:7mm; color:green">';' </SPAN>
<SPAN STYLE="font-size:7mm; color:black">)[0]) </SPAN><BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:black">user_dict[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'number_test'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">+=1</SPAN><BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:black">user_dict[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'tests'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">+=[test]</SPAN><BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:black">f=</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">open </SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'user.dat'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'wb'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:black">pickle.dump(user_dict,f)</SPAN><BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:black">f.close()</SPAN> <BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#ff8000">else </SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN> <BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:black">
write_results(user_dict,out_points=1,out_tests=1,out_answers=1)</SPAN> <BR>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>
<p> В начале своей работы программа <SPAN CLASS="svoj">testing.py</SPAN> подключает необходимые ей
для работы модули: <SPAN CLASS="svoj">cgi</SPAN>, <SPAN CLASS="svoj">cgitb</SPAN>,
<SPAN CLASS="svoj">random</SPAN>, <SPAN CLASS="svoj">pickle</SPAN> и функцию 
<SPAN CLASS="svoj">write_results</SPAN> с константой <SPAN CLASS="svoj">D</SPAN> из модуля
<SPAN CLASS="svoj">my_mod</SPAN>. После получения запроса от клиента программа преобразует,
используя метод <SPAN CLASS="svoj">parse()</SPAN> модуля <SPAN CLASS="svoj">cgi</SPAN>,
полученные данные в словарь <SPAN CLASS="svoj">data</SPAN> и осуществляет их анализ. <BR>
<SPAN CLASS="txt_abz">Если </SPAN>клиентская часть передала имя пользователя, т.е. словарь
<SPAN CLASS="svoj">data</SPAN> содержит ключ <SPAN CLASS="svoj">"name"</SPAN>, то выполняются
следующие действия:
<UL CLASS="list">                                           
<LI> с помощью функции get_test('tests.dat'), аргументом которой является имя файла, содержащего
разработанные тесты (см. <a href="#2.2">подраздел 2.2.1</a>), осуществляется выбор теста с именем
test:
<UL CLASS="list2">                                           
<LI> из файла, заданного аргументом filename, выполняется с помощью метода load() модуля pickle
чтение двоичных данных и преобразование их в список тестов test_list;
<LI> с помощью метода choice() модуля random из списка test_list осуществляется случайный выбор
теста и занесение его содержимого в переменную test; 
<LI> производится удаление этого теста из test_list и запись с помощью метода dump() модуля pickle
измененного списка тестов в файл "cur_tests.dat", который отличается от файла "tests.dat" тем, что
содержит только те тесты, вкоторые еще не были использованы при тестировании;
<LI> возвращается содержимое выбранного теста;
</UL>
<LI> у выбранного теста выделяется его часть, не содержащая эталонное значение, и передается
клиенту в следующем виде (см. <a href="#2.2">подраздел 2.2.1</a>):<br><br>
<P class="ba" style='margin-left:1.5cm;color:#0000b0; font-size:5.7mm'>
Тест №3. <i><b>Выполняется удаление существующего файла</i></b>:<br>
1. mode='w'></span><br> 
2. mode='w+'<br> 
3. mode='a';</span><br><br>
<LI> выполняется создание словаря пользователя user_dict и инициализация его элементов:
<UL CLASS="list2">                           
<LI> элемент с ключем "name" класса str получает значение имени, переданное клиентом &ndash;
data['name'][0];
<LI> элемент с ключем "number_test" класса int, предназначенный для хранения числа переданных
клиенту тестов, получает значение 1;
<LI> элемент с ключем "tests" класса list, предназначенный для хранения тестов, переданных
клиенту, получает значение переменной test; 
<LI> элемент с ключем "answers" класса list, предназначенный для хранения ответов пользователя
при тестировании, получает пустое значение ([]), поскольку на этом этапе от клиента было получено
только имя пользоватея;
<LI> элемент с ключем "points" класса int, предназначенный для хранения числа набранных баллов
получает начальное значение 0.
</UL>
<LI> текущее состояние словаря пользователя user_dict запоминается в файле 'user.dat';
</UL>
<P>Если клиентская часть передает значение ответа пользователя, т.е. словарь полученных данных
<SPAN CLASS="svoj">data</SPAN> содержит ключ "answers", то выполняются следующие действия:
<UL CLASS="list"> 
<LI> производится считывание из файла 'user.dat' текущего значения словаря данных пользователя и
добавление в его элемент с ключем 'answers', хранящий в виде списка ответы пользователя, значение
очередного ответа;
<LI> из словаря пользователя выбирается список тестов, заданных пользователю, в нем определяется
последний тест и из этого теста берется эталонное значение, которое заносится в переменную etalon;
<LI> производится сравнение полученного от пользователя ответа с эталонным значением и, если ответ
правильный, число набранных баллов пользователя увеличивается на 1; 
<LI> проверяется текущее значение числа проведенных тестов (элемент "number_test" словаря данных
пользователя) с числом тестов, указанных для тестирования (max_test) и, если оно меньше, т.е.
тестирование не закончено, то выполняются следующие действия:
<UL CLASS="list2">                                           
<LI> чтение с помощью функции get_test('cur_tests.dat') модифицированного набора тестов (чтобы
тесты не повторялись), случайный выбор одного из них, модификаця файла 'cur_tests.dat' и передача
клиенту очередного теста;
<LI> производится изменение элементов с ключами "number_test" и "tests" словаря пользователя
&ndash; значение "number_test" увеличивается на 1, к значению "tests" добавляется новый тест;
<LI> текущее состояние словаря пользователя user_dict запоминается в файле 'user.dat';
</UL>
<LI> если значение элемента "number_test" равно или больше max_test, то тестирование прекращается
и его результаты передаются клиенту с помощью функции write_results() (описание функции см. в
<a href="#2.2.3">подразделе 2.2.3</a>):<p> 
</UL>

<P class="ba" style='margin-left:1.5cm;color:#0000b0; font-size:5.7mm'>
<i><b>Результаты тестирования:</b></i> <br>
Имя – Сидоров Евгений <br>
Оценка – "Отлично" </p>
<!--
<LI> результаты тестирования  также записываются в файл "all_users.dat" для последующего анализа
(см. ).        -->
<A NAME="2.2.3">
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod1">2.2.3 Передача результатов тестирования</H4>
<P>Для передачи клиенту результатов проведенного тестирования разработана функция
<SPAN CLASS="svoj">write_results()</SPAN>:<br><br>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#ff8000">def</SPAN>
<SPAN STYLE="font-size:7mm; color:blue">write_results</SPAN>
<SPAN STYLE="font-size:7mm; color:black">
(user_dict, out_points=0, out_tests=0, out_answers=0): </SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(D,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'&lt;i>&lt;b>Результаты тестирования:&lt;/b>&lt;/i>'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN><BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:green">'&lt;br>Имя &amp;ndash; ' </SPAN>
<SPAN STYLE="font-size:7mm; color:black">, user_dict[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'name'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]) </SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#ff8000">if </SPAN>
<SPAN STYLE="font-size:7mm; color:black">out_points: </SPAN><BR>       
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'&lt;br>Получено баллов &amp;ndash; ' </SPAN>
<SPAN STYLE="font-size:7mm; color:black">, </SPAN><BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:black">user_dict[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'points'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">],</SPAN>
<SPAN STYLE="font-size:7mm; color:green">' из '</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, user_dict[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'number_test'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]) </SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#ff8000">if </SPAN>
<SPAN STYLE="font-size:7mm; color:black">out_tests: </SPAN><BR>       
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'&lt;br>Тесты &amp;ndash; '</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:#ff8000">for </SPAN>
<SPAN STYLE="font-size:7mm; color:black">el </SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">in </SPAN>
<SPAN STYLE="font-size:7mm; color:black">user_dict[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'tests'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]:</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(el.split(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'.'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)[0])</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#ff8000">if </SPAN>
<SPAN STYLE="font-size:7mm; color:black">out_answers: </SPAN><BR>       
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'&lt;br>Ответы &amp;ndash; '</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:5.9cm; font-size:7mm; color:#ff8000">for </SPAN>
<SPAN STYLE="font-size:7mm; color:black">el </SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">in </SPAN>
<SPAN STYLE="font-size:7mm; color:black">user_dict[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'answers'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]:</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(el)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'&lt;br>Оценка &amp;ndash; '</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:black">m=user_dict[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'points'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#ff8000">if</SPAN>
<SPAN STYLE="font-size:7mm; color:black">m==0: mark=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"Неудовлетворительно"</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#ff8000">elif</SPAN>
<SPAN STYLE="font-size:7mm; color:black">m==1: mark=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"Удовлетворительно"</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#ff8000">elif</SPAN>
<SPAN STYLE="font-size:7mm; color:black">m==2: mark=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"Хорошо"</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#ff8000">else</SPAN>
<SPAN STYLE="font-size:7mm; color:black">: mark=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"Отлично"</SPAN><BR>
<SPAN STYLE="margin-left:3.7cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'"'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, mark,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'"'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]</SPAN>,<BR><BR>
которая имеет один обязательный параметр &ndash; словарь <SPAN CLASS="svoj">user_dict</SPAN>,
содержающий следующие ключи, отражающие отдельные компоненты тестирования:
<UL CLASS="list"> 
<LI> name &ndash; имя тестируемого;
<LI> number_test &ndash; число проведенных тестов;
<LI> tests &ndash; список этих тестов;
<LI> answers &ndash; список ответов тестируемого;
<LI> points &ndash; число набранных при тестировании баллов
</UL>
<p class="ba">и необязательные (опциональные) параметры: out_points, out_tests и  out_answers,
которые указывают, надо ли передавать для вывода на стороне клиента значение соответствующей
компоненты тестирования (значение 1), или нет (значение 0). По умолчанию все они имеют значение 0,
т.е. если не указывать эти аргументы при вызове функции <SPAN CLASS="svoj">write_results()</SPAN>,
то такие данные, как число проведенных тестов, список тестов, список ответов и число баллов
выводиться не будут. Будет выведено только имя тестирующего и полученная им оценка (см. работу
программы <SPAN CLASS="svoj">testing.py</SPAN> в <a href="#2.2.2">подразделе 2.2.2</a>). <br>
<SPAN CLASS="txt_abz">Чтобы </SPAN>получить наиболее полную информацию о проведенном тестировании,
нужно вызвать функцию <SPAN CLASS="svoj">write_results()</SPAN>, указав в ней значения всех
необязательных аргументов, равными 1: <BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:black">
write_results(user_dict,out_points=1,out_tests=1,out_answers=1)</SPAN>
<p>При этом клиенту будет передана информация в следующем виде:
<P class="ba" style='margin-left:1.5cm;color:#0000b0; font-size:5.7mm'>
<i><b>Результаты тестирования:</b></i> <br>
Имя – Сидоров Евгений <br>
Получено баллов – 3 из 3 <br>
Тесты – Тест №3 Тест №1 Тест №5 <br>
Ответы – 100 010 111 <br>
Оценка – " Хорошо "  </p>
<A NAME="ind"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<p>
#!c:/Documents and Settings/ZYKOV/AppData/Local/Programs/Python/Python35-32/python.exe <br>
print ( "Content-Type: text/html" ) <br>
print ()<br>

import cgi, cgitb, pickle, random <br>
from my_mod import write_results,D <br>
cgitb.enable() <br>
data=cgi.parse() <br>
f=open('all_users.dat','rb')  <br>
if "name" in data:  <br>
    if data["name"][0]=='all':  <br>
        print(D,'all') <br>
        while True: <br>
            try:  <br>
                user_dict=pickle.load(f) <br>
                write_results(user_dict,points=1, tests=1, answers=1) <br>
            except EOFError: break <br>
    else: <br>
        found=False<br>
        while True: <br>
            try: <br>
                user_dict=pickle.load(f) <br>
                if user_dict["name"]==data["name"][0]: <br>
                    write_results(user_dict,points=1,tests=1,answers=1) <br>
                    found=True <br>
            except EOFError: <br>
                if not found:<br>
                    print(D,data["name"][0],": Результаты тестироемого не найдены") <br>
                break <br>
f.close()<br>








<H3>Индивидуальные задания</H3>
<P>Разработать приложение на базе технологий "клиент-сервер" и AJAX, осуществляющее тестирование
пользователя на стороне клиента.<BR> 
<SPAN CLASS="txt_abz">Клиентскую </SPAN>часть реализовать в виде HTML-документа с включенными
фрагментами JavaScript, задачами которого являются:
<UL CLASS="list">                                           
<LI> прием имени пользователя (способ реализации указан в табл. 1);
<LI> передача на сервер имени пользователя с использованием AJAX-технологии;
<LI> прием из сервера тестов с использованием AJAX-технологии и визуализация их на
Web-странице (способ реализации указан в табл. 1);
<LI> прием ответов пользователя (способ реализации указан в табл. 1);
<LI> прием из сервера результатов тестирования с использованием AJAX-технологии и визуализация
их на Web-странице (так же, как и тесты).
</UL>
<P>В задачи серверной части приложения входит: 
<UL CLASS="list">                                           
<LI>&nbsp; Разработка не менее четырех тестов в виде списка строк по одной из следующих тем (язык
Python):
<UL CLASS="list2">
<LI> 1) строки;
<LI> 2) кортежи и списки;
<LI> 3) множества и сериализация;
<LI> 4) словари;
<LI> 5) операторы;
<LI> 6) функции и сортировка элементов;
<LI> 7) работа с файлами;
</UL>
и сохранение его на диске в виде двоичного файла. Номер темы для варианта указан в табл. 1;
<LI> Каждый тест состоит из заголовка, в котором указывается номер теста, основной части и
эталонного значения ответа. Основная часть теста состоит из вопроса/утверждения и трех вариантов
ответа. При разработке вариантов ответов необходимо реализовать одно из следующих правил
определения эталонного значения ответа:
<UL CLASS="list2">
<LI> 1) это номер единственного истинного варианта ответа;
<LI> 2) это номер единственного ложного варианта ответа;
<LI> 3) это 1 &ndash; если большинство вариантов ответов истинные, и 0 &ndash; если большинство
вариантов ответов ложные; 
</UL>
номер правила указан в табл. 1;
<LI> прием данных от клиента;
<LI> определение фамилии и ответов тестируемого пользователя;
<LI> выбор случайным образом одного из тестов и передача его на сторону клиента; 
<LI> число тестов, переданных пользователю должно быть не менее трех;
<LI> формирование словаря, содержащего такие данные о процессе тестирования: 
<UL CLASS="list2">
<LI> 1)фамилию пользователя, число выполненных тестов, число правильных ответов; 
<LI> 2)фамилию и ответы пользователя, число правильно выполненных тестов; 
<LI> 3)фамилию и ответы пользователя, правильные ответы; 
</UL>
номер содержимого словаря для варианта указан в табл. 1;
<LI> после окончания тестирования передача клиенту собранных данных.
</UL>
<P><table align="center" width="80%" border cellspacing="0">
<CAPTION ALIGN="top"><p class="ba">Таблица 1 &ndash; Параметры индивидуальных заданий</CAPTION>
<TR><TH>Номер<BR>п/п<TH>Ввод<BR>имени<TH>Ввод<BR>ответов<TH>Вывод<BR>тестов<TH>Тема<BR>тестов<TH>Правило<BR>тестов<TH>Данные<BR>словаря
<TR ALIGN=center><TD>1<TD>&lt;input><TD>prompt()<TD>prompt()<TD>1)<TD>1)<TD>2)
<TR ALIGN=center><TD>2<TD>&lt;input><TD>prompt()<TD>&lt;div /><TD>2)<TD>2)<TD>3)
<TR ALIGN=center><TD>3<TD>prompt()<TD>&lt;input><TD>&lt;div /><TD>3)<TD>3)<TD>1) 
<TR ALIGN=center><TD>4<TD>&lt;input><TD>prompt()<TD>prompt()<TD>4)<TD>1)<TD>2)
<TR ALIGN=center><TD>5<TD>&lt;input><TD>prompt()<TD>&lt;div /><TD>5)<TD>2)<TD>3)
<TR ALIGN=center><TD>6<TD>prompt()<TD>&lt;input><TD>&lt;div /><TD>6)<TD>3)<TD>1)
<TR ALIGN=center><TD>7<TD>&lt;input><TD>prompt()<TD>prompt()<TD>7)<TD>1)<TD>2)
<TR ALIGN=center><TD>8<TD>&lt;input><TD>prompt()<TD>&lt;div /><TD>1)<TD>2)<TD>3)
<TR ALIGN=center><TD>9<TD>prompt()<TD>&lt;input><TD>&lt;div /><TD>2)<TD>3)<TD>1)
<TR ALIGN=center><TD>10<TD>&lt;input><TD>prompt()<TD>prompt()<TD>3)<TD>1)<TD>2)
<TR ALIGN=center><TD>11<TD>&lt;input><TD>prompt()<TD>&lt;div /><TD>4)<TD>2)<TD>3)
<TR ALIGN=center><TD>12<TD>prompt()<TD>&lt;input><TD>&lt;div /><TD>5)<TD>3)<TD>1)
<TR ALIGN=center><TD>13<TD>&lt;input><TD>prompt()<TD>prompt()<TD>6)<TD>1)<TD>2)
<TR ALIGN=center><TD>14<TD>&lt;input><TD>prompt()<TD>&lt;div /><TD>7)<TD>2)<TD>3)
<TR ALIGN=center><TD>15<TD>prompt()<TD>&lt;input><TD>&lt;div /><TD>1)<TD>3)<TD>1)
<TR ALIGN=center><TD>16<TD>&lt;input><TD>prompt()<TD>prompt()<TD>2)<TD>1)<TD>2)
<TR ALIGN=center><TD>17<TD>&lt;input><TD>prompt()<TD>&lt;div /><TD>3)<TD>2)<TD>3)
<TR ALIGN=center><TD>18<TD>prompt()<TD>&lt;input><TD>&lt;div /><TD>4)<TD>3)<TD>1)
<TR ALIGN=center><TD>19<TD>&lt;input><TD>prompt()<TD>prompt()<TD>5)<TD>1)<TD>2)
<TR ALIGN=center><TD>20<TD>&lt;input><TD>prompt()<TD>&lt;div /><TD>6)<TD>2)<TD>3)
</TABLE>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

