<HTML>
<HEAD>
<TITLE>Лабораторная работа 6: Разработка функций и модулей пользователя</TITLE>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../heads.css">
<STYLE>TH,TD{font-size:5.5mm;border:1 double blue}</STYLE>
</HEAD>
<BODY>
<H1> ЛАБОРАТОРНАЯ РАБОТА №6</H1>
<H2> <SPAN CLASS="beg">Тема: </SPAN>Разработка функций и модулей пользователя</H2>
<H2> <SPAN CLASS="beg">Цель: </SPAN>
Рассмотрение особенностей разработки функций и модулей пользователя</H2>
<A NAME="beg"></A>
<H3>ОГЛАВЛЕНИЕ</H3> 
<A CLASS="com" HREF="#1">1 Создание функций пользователя<BR>
<A CLASS="com" HREF="#1.1">1.1 Описание функции<BR>
<A CLASS="com1" HREF="#1.1.1">1.1.1 Использование позиционных аргументов<BR>
<A CLASS="com1" HREF="#1.1.2">1.1.2 Использование именованных аргументов<BR>
<A CLASS="com1" HREF="#1.1.3">1.1.3 Использование аргументов, заданных по умолчанию<BR>
<A CLASS="com1" HREF="#1.1.4">1.1.4 Использование аргументов, заданных списком<BR>
<A CLASS="com1" HREF="#1.1.5">1.1.5 Использование аргументов, заданных словарем<BR>
<A CLASS="com1" HREF="#1.2">1.2 lambda функции<BR>
<A CLASS="com1" HREF="#1.3">1.3 Замыкание<BR>
<A CLASS="com" HREF="#1.4">1.4 Использование функции при сортировке<BR>
<A CLASS="com" HREF="#1.5">1.5 Использование функций при фильтрации и формировании данных<BR>
<A CLASS="com1" HREF="#1.5">1.5.1 Использование функции filter()<BR>
<A CLASS="com1" HREF="#1.5.2">1.5.2 Использование функции map()<BR>
<A CLASS="com1" HREF="#1.5.3">1.5.3 Использование оператора yield<BR>
<A CLASS="com" HREF="#2">2 Пространства имен и области видимости<BR>
<A CLASS="com" HREF="#2">2.1 Пространство имен<BR>
<A CLASS="com" HREF="#2.2">2.2 Область видимости<BR>
<A CLASS="com" HREF="#2.3">2.3 Пространства имен и области видимости при описании функций<BR>
<A CLASS="com" HREF="#2.4">2.4 Определение пространства имен в модулях и функциях <BR>
<A CLASS="com" HREF="#3">3 Создание модулей пользователя <BR>
<A CLASS="com" HREF="#4">4 Компиляция и выполнение фрагментов кода<BR>
<A CLASS="com" HREF="#4.1">4.1 Функция compile()<BR>
<A CLASS="com" HREF="#4.2">4.2 Функция exec()<BR>
<A CLASS="com" HREF="#4.3">4.3 Функция eval()<BR>
<A CLASS="com" HREF="#ind">Индивидуальные задания<BR>
<A NAME="1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4>1 Создание функций пользователя</H4>
<P>Помимо использования встроенных функций языка Python и методов его классов, пользователь
может создавать и использовать свои собственные функции. 
<A NAME="1.1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.1 Описание функции</H4>
<P>Описание любой функции начинается со служебного слова <SPAN CLASS="svoj">def</SPAN> и имеет
следующий вид<BR><BR>
<SPAN CLASS="txt_abz"> </SPAN><SPAN STYLE="font-size:7.2mm">def &lt;имя функции>
([&lt;параметры>]):<BR>
<SPAN CLASS="txt_abz"> </SPAN><SPAN CLASS="txt_abz"> </SPAN>&lt;блок>.</SPAN>
<P>Функция может не иметь формальных параметров, иметь один такой параметр или несколько. Если
функция имеет несколько параметров, то они перечисляются через запятую.<BR>
<SPAN CLASS="txt_abz"> </SPAN> Первой строкой блока функции может быть строка ее документирования
(docstring), которая берется в тройные кавычки и в среде IDLE появляется на экране в качестве
подсказки при вызове функции во время задания аргументов (см. также использование строки
документирования при объявлении классов в
<A HREF="../LAB11/lab.htm#1">подразделе 1.1</A> лаб. раб. №11).<BR>
<SPAN CLASS="txt_abz">Для </SPAN>возвращения значения функции используется оператор
<SPAN CLASS="svoj">return</SPAN>. Если возвращается несколько значений, то они должны быть указаны
в виде списка (см. <a href="../LAB3/lab.htm#2">раздел 2 </a> лаб. раб. №3). Если
оператор <SPAN CLASS="svoj">return</SPAN> не задан в блоке функции или указан без операнда,
возвращается значение <SPAN CLASS="svoj">None</SPAN>
(см. встроенные типы в <A HREF="../LAB1/lab.htm#4"> разделе 4</A> лаб. раб. №1).<BR>
<SPAN CLASS="txt_abz">Функцию </SPAN>можно определять в модуле, внутри другой функции
(см. <A HREF="#1.3">подраздел 1.3</a>) или в классе
(см. <A HREF="../LAB11/lab.htm#1.1"> подраздел 1.1</A> лаб. раб. №11). Функция, определенная
в классе, называется методом.<BR>
<SPAN CLASS="txt_abz">Функции </SPAN>в языке Python являются объектами. С ними можно работать как и
с другими объектами языка. В этом состоит их отличие от функций в таких языках, как Java, C++ и C#. <BR>
<SPAN CLASS="txt_abz">При </SPAN>вызове фукнции указыается ее имя и в скобках &ndash; аргументы
(если функция их имеет). Число аргументов и их типы должны соответствовать числу и типам параметров
функции. При выполнении функции значения аргументов присваиваются соответствующим параметрам. <BR>
<SPAN CLASS="txt_abz"> В </SPAN>качестве примера создания функции, рассмотрим задачу генерации
чисел Фибоначчи, уже приведенную в <A HREF="../LAB1/lab.htm#6.3">подразделе 6.3</A>
лаб. раб. №1. Но теперь решение этой задачи реализуем в виде функции
<SPAN CLASS="svoj">fibo(k)</SPAN>, которая определяет первые <SPAN CLASS="svoj">k</SPAN> чисел
Фибоначчи и возвращает их в виде списка:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">fibo</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(k):</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:green">
'''Формирование чисел Фибоначчи (k &ndash; их количество)'''</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:black">a,b,i,f=0,1,0,[]</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">while</SPAN>
<SPAN STYLE="font-size:7mm; color:black">i&lt;k:</SPAN><BR>
<SPAN STYLE="margin-left:5.3cm; font-size:7mm; color:black">f+=[b]</SPAN><BR>
<SPAN STYLE="margin-left:5.3cm; font-size:7mm; color:black">a,b=b,a+b</SPAN><BR>
<SPAN STYLE="margin-left:5.3cm; font-size:7mm; color:black">i+=1</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">return</SPAN>
<SPAN STYLE="font-size:7mm; color:black">f</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Отметим, </SPAN>что созданная функция является объектом: <BR><BR> 
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">isinstance</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(fibo, object))</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">True</SPAN>,<BR><BR>
который можно вызвать по имени, потому что встроенная функция <SPAN CLASS="svoj">callable()</SPAN>
(см. <A HREF="../LAB1/lab.htm#callable">раздел 8.1</A> лаб. раб. №1) возвращают значение
True:
<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">callable</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(fibo))</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">True</SPAN>,<BR><BR>
и получить 10 чисел Фибоначчи:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(fibo(10))</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</SPAN><BR><BR>

<SPAN CLASS="txt_abz">Функция </SPAN><SPAN CLASS="svoj">fibo()</SPAN> оформлена в виде файла
</SPAN><SPAN CLASS="svoj">. . . \LAB6\fibo.py</SPAN>, имеет один параметр
</SPAN><SPAN CLASS="svoj">k</SPAN>, с помощью которого пользователь задает число необходимых ему
чисел Фибоначчи. В строке документирования указано назначение функции и ее параметра. <BR>
<SPAN CLASS="txt_abz">Имеется </SPAN>несколько способов передачи значений параметрам функции:
<UL CLASS="list">
<LI> с помощью позиционных аргументов (см. <a href="#1.1.1">подраздел 1.1.1 </a>);
<LI> с помощью именнованных аргументов (см. <a href="#1.1.2">подраздел 1.1.2 </a>);
<LI> с помощью аргументов, имеющих значения по умолчанию
(см. <a href="#1.1.3">подраздел 1.1.3 </a>);
<LI>  с помощью аргументов, заданных списком (см. <a href="#1.1.4">подраздел 1.1.4 </a>);
<LI> с помощью аргументов, заданных словарем (см. <a href="#1.1.5">подраздел 1.1.5 </a>).
</UL>
<A NAME="1.1.1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.1.1 Использование позиционных аргументов</H4>
<P>Позиционными являются такие аргументы функции, порядок которых при вызове функции строго
определен порядком параметров функции, т.е. их позицией. Нарушение порядка следования аргументов
(кроме отдельных случаев, когда порядок параметров неважен) приведет к нарушению правильной работы
функции (см. <a href="#1.1.2">подраздел 1.1.2 </a>). <BR>
<SPAN CLASS="txt_abz">Рассмотрим </SPAN>пример создания функции, имеющей несколько позиционных
параметров:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">val</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(x, y, op):</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">if </SPAN>
<SPAN STYLE="font-size:7mm; color:black">op==</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'+'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:#ff8000">return </SPAN>
<SPAN STYLE="font-size:7mm; color:black">x+y</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">elif </SPAN>
<SPAN STYLE="font-size:7mm; color:black">op==</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'-'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:#ff8000">return </SPAN>
<SPAN STYLE="font-size:7mm; color:black">x-y</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">elif </SPAN>
<SPAN STYLE="font-size:7mm; color:black">op==</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'*'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:#ff8000">return </SPAN>
<SPAN STYLE="font-size:7mm; color:black">x*y</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">elif </SPAN>
<SPAN STYLE="font-size:7mm; color:black">op==</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'/'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:#ff8000">return </SPAN>
<SPAN STYLE="font-size:7mm; color:black">x/y</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">else </SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:#ff8000">return </SPAN>
<SPAN STYLE="font-size:7mm; color:green">'Неверная операция'</SPAN>.<BR><BR>
<SPAN CLASS="txt_abz">Параметры </SPAN><SPAN CLASS="svoj">x</SPAN> и <SPAN CLASS="svoj"> y</SPAN>
задают операнды, а <SPAN CLASS="svoj">op</SPAN> &ndash; одну из следующих арифметических операций:
сложение, вычитание, умножение или деление. Функция возвращает результат выполненной операции:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">val(3, 2, </SPAN>
<SPAN STYLE="font-size:7mm; color:green">'+'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">5</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Если </SPAN>будет указана недопустимая операция<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">val(3, 2,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'//'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN>,<BR><BR>
функция в качестве значения возвращает сообщение:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'Неверная операция'</SPAN>.<BR>
<A NAME="1.1.2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.1.2 Использование именованных аргументов</H4>
<P>Как было указано в <a href="#1.1.1">подразделе 1.1.1 </a> в случае использования позиционных
аргументов существует опастность нарушения порядка следования аргументов при вызове функции,
например: <BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">val(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'+'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, 3, 2)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'Неверная операция'</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Чтобы </SPAN>этого не произошло, а также для более ясного текста программы,
в языке Python разрешено использовать именованные аргуметы, т.е. аргументы, в которых кроме
значения указывается также имя параметра. В таком случае при вызове функции аргументы могут быть
указаны в любом порядке:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">val(op=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'+'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, x=3, y=2)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">5</SPAN><BR><BR> 
<SPAN CLASS="txt_abz">Отметим, </SPAN>что можно одновременно использовать именованные аргументы
и позиционные. Надо только следить за тем, чтобы справа от именованного аргумента были указаны
только именованные аргументы:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">val(3,op=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'+'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, y=2)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">5</SPAN><BR>
<A NAME="1.1.3"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.1.3 Использование аргументов, заданных по умолчанию</H4>
<P>В языке Python разрешено также использование аргументов с заданными по умолчанию значениями.
Это полезно делать в случаях, когда значения параметров изменяются достаточно редко. Например,
если функция <SPAN CLASS="svoj">val()</SPAN> (см. <a href="#1.1.1">подраздел 1.1.1</a>)
используется в основном для выполнения операции сложения, то ее параметры можно описать следующим
образом (остальная часть функции не изменилась):
<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">val</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(x, y, op=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'+'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">):</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Тогда </SPAN>для выполнения операции сложения при вызове функции третий
аргумент указывать не следует:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">val(3, 2)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">5</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Если </SPAN>же функцию <SPAN CLASS="svoj">val()</SPAN> необходимо использовать
для умножения чисел, то тогда явно нужно указать третий параметр, значение которого переопределяет
значение, заданное по умолчанию:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">val(3, 2, </SPAN>
<SPAN STYLE="font-size:7mm; color:green">'*'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">6</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Описание функции </SPAN><SPAN CLASS="svoj">val()</SPAN> можно упростить и
расширить ее возможности, применив встроенную функцию </SPAN><SPAN CLASS="svoj">eval()</SPAN>
(см. <A HREF="#4.3">подраздел 4.3</A>).
<A NAME="1.1.4"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.1.4 Использование аргументов, заданных списком</H4>
<P>Python позволяет создавать функции с переменным числом значений аргументов. Для этого перед
именем парамера необходимо указать символ <SPAN CLASS="svoj">*</SPAN>. При  вызове функции
переданные значения для данного параметра представляются в виде списка, т.е. в виде заключенной в
квадратные скобки последовательности данных, разделенных запятыми
(см. описание списков в <a href="../LAB3/lab.htm#2">разделе 2 </a> лаб. раб. №3), элементы
которого можно обрабатывать в теле функции. В качестве примера приведем описание функции,
выполняющей сложение произвольного числа слагаемых:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">sum1</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(*args):</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:black">s=0</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">for</SPAN>
<SPAN STYLE="font-size:7mm; color:black">el</SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">in</SPAN>
<SPAN STYLE="font-size:7mm; color:black">args:</SPAN><BR>
<SPAN STYLE="margin-left:6.0cm; font-size:7mm; color:black">s+=el</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">return</SPAN>
<SPAN STYLE="font-size:7mm; color:black">s</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">sum1(3,5,7,2)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">17</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Можно </SPAN>также, задав список значений:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">a_list=[7,9,3,11]</SPAN><BR><BR>
вызвать функцию, указав в качестве аргумента имя списка с впереди стоящей звездочкой:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">sum1(*a_list)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">30</SPAN><BR>
<A NAME="1.1.5"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.1.5 Использование аргументов, заданных словарем</H4>
<P>Другим вариантом создания функции с переменным числом аргументов является использование перед
именем парамера двух символов "звездочка" (<SPAN CLASS="svoj">**</SPAN>). В этом случае при вызове
функции переданные значения аргумента представляются в виде словаря
(см. описание словарей <A HREF="../LAB5/lab.htm#2"> в разделе 2</A> лаб. раб. №5).
В качестве примера приведем описание функции <SPAN CLASS="svoj">list_of_keys()</SPAN>, имеющей два
аргумента &ndash; первый (позиционный) <SPAN CLASS="svoj">color</SPAN> указывает цвет, второй
<SPAN CLASS="svoj">**args</SPAN> указывает на аргумент в виде словаря. Функция просматривает
элементы словаря и сравнивает их значения с значением первого аргумента. При совпадении значений
ключ элемента словаря заносится в формируемый список ключей, который возвращает функция:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">list_of_keys</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(color, **args):</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:black">l_color=[]</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">for</SPAN>
<SPAN STYLE="font-size:7mm; color:black">k</SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">in</SPAN>
<SPAN STYLE="font-size:7mm; color:black">args:</SPAN><BR>
<SPAN STYLE="margin-left:6.5cm; font-size:7mm; color:#ff8000">if </SPAN>
<SPAN STYLE="font-size:7mm; color:black">args[k]==color:</SPAN><BR>
<SPAN STYLE="margin-left:8.0cm; font-size:7mm; color:black">l_color+=[k]</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">return </SPAN>
<SPAN STYLE="font-size:7mm; color:black">l_color</SPAN><BR> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">a_dict={</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'1'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'blue'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'2'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'blue'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'3'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'red'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'4'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'blue'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'5'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'green'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'6'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'green'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'7'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'blue'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">}</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">list_of_keys(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'blue'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, **a_dict)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">['1', '2', '7', '4']</SPAN><BR><BR>
<A NAME="1.2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.2 lambda функции</H4>
<P><SPAN CLASS="svoj">lambda</SPAN> функции широко используются в языках функционального
программирования. Поэтому в языке Python осуществлена их поддержка:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">f1</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(n):</SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">return</SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">lambda</SPAN>
<SPAN STYLE="font-size:7mm; color:black">x:x**n</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">f2=f1(3)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">f2(5)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">125</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Можно </SPAN>просто вызвать функцию <SPAN CLASS="svoj">f1</SPAN>:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">f1(3)(5)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">125</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Использование </SPAN><SPAN CLASS="svoj">lambda</SPAN> функции показано также
в <a href="#1.5.2">подразделе 1.5.2</a>.
<A NAME="1.3"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.3 Замыкание</H4>
<P>Замыкание &ndash; это особый вид функции, которая определена в теле другой функции и создается
каждый раз при выполнении внешней функции. При этом вложенная внутренняя функция содержит ссылки на
локальные переменные внешней функции.<BR>
<SPAN CLASS="txt_abz">Ссылки </SPAN>на переменные внешней функции в случае замыкания действительны
внутри вложенной функции даже если внешняя функция завершила работу и переменные вышли из области
видимости. В объекте &ndash; функции привязаны к данным, в замыкании &ndash; данные привязаны
к функции.<BR>
<SPAN CLASS="txt_abz">Приведем </SPAN>пример простого замыкания:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">make_add</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(x):</SPAN><BR>
<SPAN STYLE="margin-left:3.8cm; font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">add</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(y):</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:#ff8000">return </SPAN> 
<SPAN STYLE="font-size:7mm; color:black">x+y</SPAN><BR>
<SPAN STYLE="margin-left:3.8cm; font-size:7mm; color:#ff8000">return </SPAN> 
<SPAN STYLE="font-size:7mm; color:black">add</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">make_add(2)(3)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">5</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Отметим, </SPAN>что в языке Python изменять значения можно только тех
переменных замыкания, которые относятся к изменяемым типам. Поэтому при выполнении примера, в
котором подчитывается число вызовов функции замыкания, заданного целочисленным типом :<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">create_counter</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(count_calls=0):</SPAN><BR>
<SPAN STYLE="margin-left:3.8cm; font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">change_counter</SPAN>
<SPAN STYLE="font-size:7mm; color:black">():</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:black">count_calls+=1</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:#ff8000">return </SPAN> 
<SPAN STYLE="font-size:7mm; color:black">count_calls</SPAN><BR>
<SPAN STYLE="margin-left:3.8cm; font-size:7mm; color:#ff8000">return </SPAN> 
<SPAN STYLE="font-size:7mm; color:black">change_counter</SPAN><BR><BR>
возникает ошибка:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:red">
nboundLocalError: local variable 'count_calls' referenced before assignment </SPAN>.<BR><BR>
<SPAN CLASS="txt_abz">Исправить </SPAN>положение можно, задав число вызовов в виде элемента списка:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">create_counter</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(count_calls=[0]):</SPAN><BR>
<SPAN STYLE="margin-left:3.8cm; font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">change_counter</SPAN>
<SPAN STYLE="font-size:7mm; color:black">():</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:black">count_calls[0]+=1</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:#ff8000">return </SPAN> 
<SPAN STYLE="font-size:7mm; color:black">count_calls[0]</SPAN><BR>
<SPAN STYLE="margin-left:3.8cm; font-size:7mm; color:#ff8000">return </SPAN> 
<SPAN STYLE="font-size:7mm; color:black">change_counter</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">create_counter()()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">1</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">create_counter()()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">2</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">create_counter()()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">3</SPAN>.<BR><BR>
<A NAME="1.4"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.4 Использование функции при сортировке</H4>
<P>Списки, помимо рассмотренных в <A HREF="../LAB3/lab.htm#2">разделе 2 </a> лаб. раб. №3 методов,
также поддерживают метод <SPAN CLASS="svoj">sort()</SPAN>, который осуществляет сортировку
элементов списка. При использовании этого метода элементами списка могут быть только данные,
которые можно сравнивать между собой &ndash; числа или строки, причем список не должен содержать
сразу и числа и строки. <BR>
<SPAN CLASS="txt_abz">Необходимо отметить, </SPAN>что метод <SPAN CLASS="svoj">sort()</SPAN>
выполнив сортировку элементов списка, не возвращает результаты своей работы, точнее, всегда
возвращает значение <SPAN CLASS="svoj">None</SPAN>. Метод не имеет обязательных параметров &ndash;
если при его вызове аргументы не заданы, то элементы списка будут отсортированы по возростанию их
значений (строки сортируются по значению кодов их символов). Например:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">a_list=[5,2.0,44,-3,27.5]</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">a_list.sort()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">a_list</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">[-3, 2.0, 5, 27.5, 44]</SPAN>,<BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">b_list=[</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'Python'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'cat'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'zz'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'A'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">]</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">b_list.sort()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">b_list</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">['A', 'Python', 'cat', 'zz']</SPAN>,<BR><BR>
<SPAN CLASS="txt_abz">Два </SPAN>необязательных параметра предназначены для изменения порядка
сортировки: 
<UL CLASS="list">
<LI> reverse &ndash; когда получает значение 1, изменяет направление сортировки: элементы
списка сортируются от большего значения к меньшему (по умолчанию reverse = 0):<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">a_list.sort(reverse=1)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">a_list</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">[44, 27.5, 5, 2.0, -3]</SPAN>;<BR><BR>
<LI> key &ndash; указывает имя функции, которая в качестве аргумента принимает значения
элементов списка и возвращает значения, используемые при сортировке списка вместо значений самих
элементов.
</UL>
<P> Для использования параметра <SPAN CLASS="svoj">key</SPAN> необходимо разработать функцию,
которая преобразовывала бы элементы списка для сравнения. Например, для сортировкм слов не по
алфавиту, а по их длине, необходимо, чтобы функция возвращала их длину:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">sort1</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(item):</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">return </SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">len </SPAN>
<SPAN STYLE="font-size:7mm; color:black">(item)</SPAN> <BR><BR>
<SPAN CLASS="txt_abz">Теперь </SPAN>выполним сортировку слов списка, расположив их в порядке
уменьшения их длин:<BR><BR> 
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">b_list.sort(key=sort1, reverse=1)</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">b_list</SPAN> <BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">['Python', 'cat', 'zz', 'A']</SPAN>,<BR><BR>
<SPAN CLASS="txt_abz">Использование </SPAN>параметра <SPAN CLASS="svoj">key</SPAN> позволяет
осуществить сортировку списков, имеющих элементы разных типов. Пусть, например, список
<SPAN CLASS="svoj">c_list</SPAN> содержит числа, списки чисел и строки:<BR><BR> 
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">c_list=[6,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'Питон'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,[3,7,6],</SPAN> 
<SPAN STYLE="font-size:7mm; color:green">'web'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,[1.6,20],0.67e1]</SPAN> <BR> <BR>
<SPAN CLASS="txt_abz">Использование </SPAN>метода <SPAN CLASS="svoj">sort()</SPAN> без аргументов <BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">c_list.sort()</SPAN> <BR><BR>
вызовет исключение <BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:red">TypeError: unorderable types: int() < list()</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN> <BR><BR>
т.е. элементы типов int и list нельзя сравнивать.<BR>
<SPAN CLASS="txt_abz">Для </SPAN>устранения этого ограничения разработаем функцию
<SPAN CLASS="svoj">sort2</SPAN>, которая анализирует тип элемента списка и возвращает следующие
значения:
<UL CLASS="list"> 
<LI> для списка &ndash; среднее арифметическое элементов списка;
<LI> для строки &ndash; ASCII код первого символа строки;
<LI> для числа &ndash; само число:
</UL>
<P CLASS="ba">
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">sort2</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(item):</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">if </SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">isinstance </SPAN>
<SPAN STYLE="font-size:7mm; color:black">(item,</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">list</SPAN>
<SPAN STYLE="font-size:7mm; color:black">):</SPAN><BR>
<SPAN STYLE="margin-left:5.6cm; font-size:7mm; color:black">s=0</SPAN><BR>
<SPAN STYLE="margin-left:5.6cm; font-size:7mm; color:#ff8000">for </SPAN>
<SPAN STYLE="font-size:7mm; color:black">el</SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">in</SPAN>
<SPAN STYLE="font-size:7mm; color:black">item:</SPAN><BR>
<SPAN STYLE="margin-left:7.6cm; font-size:7mm; color:black">s+=el</SPAN><BR>
<SPAN STYLE="margin-left:5.6cm; font-size:7mm; color:#ff8000">return </SPAN>
<SPAN STYLE="font-size:7mm; color:black">s/</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">len</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(item)</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">elif </SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">isinstance </SPAN>
<SPAN STYLE="font-size:7mm; color:black">(item,</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">str</SPAN>
<SPAN STYLE="font-size:7mm; color:black">):</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:#ff8000">return </SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">ord</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(item[0])</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">else</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:#ff8000">return </SPAN>
<SPAN STYLE="font-size:7mm; color:black">item</SPAN><BR><BR>
<SPAN CLASS="txt_abz">После </SPAN>вызова метода сортировки<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">c_list.sort(key=sort2)</SPAN><BR><BR>
получаем отсортированный список<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">c_list</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
[[3, 7, 6], 6, 6.7, [1.6, 20], 'web', 'Питон']</SPAN>
<SPAN STYLE="font-size:7mm; color:black">.</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Чтобы </SPAN>сделать копию результата сортировки (без изменения самого
списка), необходимо вместо использования метода  <SPAN CLASS="svoj">sort()</SPAN> применить
встроенную фукнцию <SPAN CLASS="svoj">sorted()</SPAN> 
(см. <A HREF="../LAB1/lab.htm#sorted"> подраздел 8.1</A> лаб. раб. №1), которая имеет те же
необязательные параметры:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">d_list=sorted(c_list,key=sort2,reverse=1)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">d_list</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
['Питон', 'web', [1.6, 20], 6.7, 6, [3, 7, 6]]</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">c_list</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
[[3, 7, 6], 6, 6.7, [1.6, 20], 'web', 'Питон']</SPAN>
<A NAME="1.5"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">1.5 Использование функций при фильтрации и формировании данных</H4>
<H4 CLASS="pod1">1.5.1 Использование функции filter()</H4>
<P>Для фильтрации данных итерабельного типа может быть использована встроенная функция
<SPAN CLASS="svoj">filter(function, iterable)</SPAN>
(см. <A HREF="../LAB1/lab.htm#filter">подраздел 8.1</A> лаб. раб. №1), которая возвращает итератор,
формируемый из тех элементов аргумента iterable, для которых второй аргумент &ndash; функция
function имеет значение True. В качестве примера рассмотрим задачу формирования простых чисел.<BR>
<SPAN CLASS="txt_abz">Сначала </SPAN>разработаем функцию <SPAN CLASS="svoj">simple()</SPAN>,
которая возвращает значение True, если ее аргументом является простое числом, и False &ndash; в
противном случае:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">simple</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(n):</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">for </SPAN> 
<SPAN STYLE="font-size:7mm; color:black">_ </SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">in  </SPAN> 
<SPAN STYLE="font-size:7mm; color:#af0af">range</SPAN> 
<SPAN STYLE="font-size:7mm; color:black">(2,n):</SPAN><BR>
<SPAN STYLE="margin-left:6.5cm; font-size:7mm; color:#ff8000">if </SPAN> 
<SPAN STYLE="font-size:7mm; color:black">n%_==0:</SPAN><BR>
<SPAN STYLE="margin-left:8.0cm; font-size:7mm; color:#ff8000">return False </SPAN> <BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">return True </SPAN> <BR><BR>
<SPAN CLASS="txt_abz">Функция <SPAN CLASS="svoj">simple(n)</SPAN> имеет параметр
<SPAN CLASS="svoj">n</SPAN>, являющийся целым числом,  и проверяет остатки от деления этого числа
на числа от 2 до <SPAN CLASS="svoj">n-1</SPAN>. Если все отатки от деления не равны 0, т.е. число
<SPAN CLASS="svoj">n</SPAN> не делится нацело ни на одно из этих чисел и, следовательно, является
простым, то возвращается значение True. Иначе возращается значение False. <BR>
<SPAN CLASS="txt_abz">Теперь </SPAN>используем функции <SPAN CLASS="svoj">filter()</SPAN> и
<SPAN CLASS="svoj">simple()</SPAN> для формирования простых чисел в диапазоне от 2 до 100:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">list</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">filter</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(simple,rang(2,100)))</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Функция </SPAN><SPAN CLASS="svoj">filter()</SPAN> возвращает значения в виде
итератора, поэтому, так же как и для объектов типа <SPAN CLASS="svoj">range</SPAN>
(см. <A HREF="../LAB4/lab.htm#2">раздел 2</A> лаб. раб. №4), необходимо
конкретизовать с помощью конструктора тип данных, например, в виде списка.
<A NAME="1.5.2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod1">1.5.2 Использование функции map()</H4>
<P> Для формирования данных может быть использована встроенная функция
<SPAN CLASS="svoj">map(function,iterable)</SPAN>
(см. <A HREF="../LAB1/lab.htm#map">подраздел 8.1</A> лаб. раб. №1), которая имеет те же аргументы,
что и функция <SPAN CLASS="svoj">map()</SPAN>, но выполняет не фильтрацию, а формирование с помощью
функции function элементов итератора из элементов iterable.<BR>
<SPAN CLASS="txt_abz">В </SPAN>качестве примера рассмотрим формирование чисел вида
<SPAN CLASS="svoj">x*x-1</SPAN>, заданного <SPAN CLASS="svoj">lambda</SPAN> функцией
(см. <a href="#1.2">подраздел 1.2 </a>), в диапазоне от 1 до 10, представленных в виде кортежа:
<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">tuple</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">map</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">lambda</SPAN>
<SPAN STYLE="font-size:7mm; color:black">x:x*x-1, </SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">range</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(1,10)))</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
(0, 3, 8, 15, 24, 35, 48, 63, 80)</SPAN><BR><BR>
<A NAME="1.5.3"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod1">1.5.3 Использование оператора yield</H4>
<P>Оператор <SPAN CLASS="svoj">yield</SPAN>, используемый в теле функции, как и оператор
<SPAN CLASS="svoj">return</SPAN> завершает ее работу, но в отличие от оператора
<SPAN CLASS="svoj">return</SPAN> возвращает генератор. Рассмотрим еще раз задачу генерации кубов
чисел (см. <A HREF="../LAB5/lab.htm#3.1">подраздел 3.1</A> лаб. раб. №5), но теперь решим ее с
использованием оператора <SPAN CLASS="svoj">yield</SPAN>:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">create_gen</SPAN>
<SPAN STYLE="font-size:7mm; color:black">():</SPAN><BR>
<SPAN STYLE="margin-left:3.9cm; font-size:7mm; color:black">l=</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">range</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(1,11)</SPAN><BR>
<SPAN STYLE="margin-left:3.9cm; font-size:7mm; color:#ff8000">for </SPAN>
<SPAN STYLE="font-size:7mm; color:black">x </SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">in </SPAN>
<SPAN STYLE="font-size:7mm; color:black">l:</SPAN><BR>
<SPAN STYLE="margin-left:5.8cm; font-size:7mm; color:#ff8000">yield </SPAN>
<SPAN STYLE="font-size:7mm; color:black">x**3</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">my_gen=create_gen()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">my_gen</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
&lt;generator object create_gen at 0x01E2B030></SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">for </SPAN>
<SPAN STYLE="font-size:7mm; color:black">x </SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">in </SPAN>
<SPAN STYLE="font-size:7mm; color:black">my_gen:</SPAN><BR>
<SPAN STYLE="margin-left:3.8cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(x, end=</SPAN>
<SPAN STYLE="font-size:7mm; color:green">' '</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
1 8 27 64 125 216 343 512 729 1000 </SPAN>.<BR><BR>
<SPAN CLASS="txt_abz">Начиная </SPAN>с версии 3.3 языка Python, появилась возможности делегировать
часть операций генератора другому генератору с помощью оператора
<SPAN CLASS="svoj">yield from</SPAN>. В качестве примера создадим функцию, которая формирует
генератор, состоящий из двух других генераторов, которые передают ему часть своих операций:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">gen</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(x):</SPAN><BR>
<SPAN STYLE="margin-left:3.8cm; font-size:7mm; color:#ff8000">yield from </SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">range</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(x,0,-1)</SPAN><BR>
<SPAN STYLE="margin-left:3.8cm; font-size:7mm; color:#ff8000">yield from </SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">range</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(x)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">list </SPAN>
<SPAN STYLE="font-size:7mm; color:black">(gen(5))</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
[5, 4, 3, 2, 1, 0, 1, 2, 3, 4]</SPAN>.<BR>
<A NAME="2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4>2 Пространства имен и области видимости</H4>
<H4 CLASS="pod">2.1 Пространство имен</H4>
<P>Пространство имен представляет собой отображение имен (идентификаторов) в объекты. По
функциональности пространства имен эквивалентны словарям и реализуются в виде словарей. В языке
Python всегда присутствуют три пространства имен:
<UL CLASS="list">   
<LI> глобальное пространство имен модуля;
<LI> локальное пространство имен, указанных в определении функции или класса;
<LI> пространство имен встроенных функций, исключений и других объектов, хранящихся в модуле
builtins.
</UL>
<P> Важно понимать, что между именами в разных пространствах имен нет связи. Например, два модуля
могут определить функции с именем “max_item”, не создавая при этом путаницы &ndash; пользователь
должен ссылаться на них с использованием имени модуля в качестве префикса.<BR>
<SPAN CLASS="txt_abz">Под </SPAN>словом атрибут (англ. attribute) будет подразумеваться любое имя,
следующее после оператора точки: например, в выражении <SPAN CLASS="svoj">z.real</SPAN>,
<SPAN CLASS="svoj">real</SPAN> является атрибутом объекта <SPAN CLASS="svoj">z</SPAN>. Строго
говоря, имена в модулях являются атрибутами модуля: в выражении
<SPAN CLASS="svoj">mod_name.func_name</SPAN>, <SPAN CLASS="svoj">mod_name</SPAN> является
объектом-модулем и <SPAN CLASS="svoj">func_name</SPAN> является его атрибутом. В этом случае имеет
место прямое соответствие между атрибутами модуля и глобальными именами, определенными в модуле:
они совместно используют одно и то же пространство имен.<BR>
<SPAN CLASS="txt_abz"> <BR>
<SPAN CLASS="txt_abz">Пространства </SPAN>имен создаются в разные моменты времени и имеют разную
продолжительность жизни:
<UL CLASS="list">   
<LI> пространство имен, содержащее встроенные имена, создается при запуске интерпретатора и
существует все время его работы;
<LI> глобальное пространство имен модуля создается при его считывании и, обычно, также существует
до завершения работы интерпретатора;
<LI> операторы, выполняемые на верхнем уровне, т.е. в интерактивном режиме или путем считывания из
файла в сценарном режиме, рассматриваются как часть модуля __main__, который автоматически
подключается при запуске интерпретатора и имеет собственное глобальное пространство имен. Отметим,
что этот объект-модуль имеет скрытый атрибут __dict__, содержащий словарь, используемый для
реализации пространства имен модуля, который не является глобальным именем. Не следует использовать
атрибут __dict__ где-либо кроме отладчиков, так как это нарушает абстракцию реализации пространства
имен;
<LI> локальное пространство имен функции создается при вызове функции и удаляется при выходе из нее
(при этом возвращается значение функции или генерируется исключение, которое не обрабатывается
внутри функции). При рекурсивном вызове функции создается собственное локальное пространство имен
для каждого вызова.
</UL>
<A NAME="2.2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">2.2 Область видимости</H4>
<P><P>Каждому </SPAN>пространству имен соответствует область видимости (англ. scope) &ndash;
фрагмент программы, в котором пространство имен доступно непосредственно, то есть имена указываются
без использования оператора точки. <BR>
<SPAN CLASS="txt_abz">Необходимо </SPAN>подчеркнуть, что область видимости определяется по тексту:
глобальная область видимости функции, определенной в модуле соответствует пространству имен этого
модуля, независимо от того, откуда или под каким псевдонимом функция была вызвана. <BR>
<SPAN CLASS="txt_abz">Является </SPAN>ли имя локальным или глобальным определяется в момент
компиляции, т.е. статически: в отсутствии оператора global имя, добавляемое где-либо в блоке кода,
является локальным во всем блоке; все остальные имена считаются глобальными. Оператор global
заставляет интерпретатор считать указанные имена глобальными.<BR>
<SPAN CLASS="txt_abz">Несмотря </SPAN>на статическое определение, области видимости используются
динамически. В любой момент времени выполнения программы имеется ровно три вложенных области
видимости (три непосредственно доступных пространства имен). Сначала поиск имени производится во
внутренней области видимости, содержащей локальные имена. Далее &ndash; в средней, содержащей
глобальные имена модуля. И, наконец, во внешней, содержащей встроенные имена.<BR>
<SPAN CLASS="txt_abz">Обычно </SPAN>локальная область видимости соответствует локальному
пространству имен текущей функции (класса, метода). За пределами функции (класса, метода)
локальная область видимости соответствует тому же пространству имен, что и глобальная: пространству
имен текущего модуля.
<A NAME="2.3"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">2.3 Пространства имен и области видимости при описании функций</H4>
<P>Все переменные, созданные внутри функций (в том числе и параметры функций) являются локальными
переменными &ndash; их область видимости ограничивается описанием функции. Они невидимы вне
функций. Например, в функции <SPAN CLASS="svoj">f1()</SPAN> объявлена локальная переменная
<SPAN CLASS="svoj">var1</SPAN>. При попытке вывести на экран ее значение вне описания функции:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">f1</SPAN>
<SPAN STYLE="font-size:7mm; color:black">():</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:black">var1=1</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(var1)</SPAN><BR><BR>
происходит исключение<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:red">NameError: name 'var1' is not defined</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Внутри </SPAN> функции переменная <SPAN CLASS="svoj">var1</SPAN> доступна:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">f1</SPAN>
<SPAN STYLE="font-size:7mm; color:black">():</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:black">var1=1</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(var1)</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">f1()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">1</SPAN><BR> <BR>
<SPAN CLASS="txt_abz">Переменные, </SPAN>созданные в программе вне функций, являются глобальными
&ndash; они видимы везде в программе, включая области описания функций, т.е. они имеют глобальную
область видимости. Глобальные переменные доступны для чтения внутри функций:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">f1</SPAN>
<SPAN STYLE="font-size:7mm; color:black">():</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:black">var1=1</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(var1,var)</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">var=10</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">f1()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">1 10</SPAN><BR> <BR>
<SPAN CLASS="txt_abz">Однако </SPAN>попытка присвоить переменной <SPAN CLASS="svoj">var</SPAN>
в теле функции новое значение приведет к тому, что переменная с этим именем будет воспринята
интерпретатором как локальная переменная, которая будет иметь в своей локальной области видимости
это значение:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">f1</SPAN>
<SPAN STYLE="font-size:7mm; color:black">():</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:black">var1=1</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:black">var=25</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(var1,var)</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">var=10</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">f1()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">1 25</SPAN><BR> <BR>
<SPAN CLASS="txt_abz">Значение </SPAN>же глобальной переменной <SPAN CLASS="svoj">var</SPAN>
осталось неизменным:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(var)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">10</SPAN><BR> <BR>
<SPAN CLASS="txt_abz">Чтобы </SPAN>функция получила возможность изменять значение глобальной
переменной, необходимо использовать оператор <SPAN CLASS="svoj">global</SPAN>:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">f1</SPAN>
<SPAN STYLE="font-size:7mm; color:black">():</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:#ff8000">global</SPAN>
<SPAN STYLE="font-size:7mm; color:black">var</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:black">var1=1</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:black">var=25</SPAN><BR>
<SPAN STYLE="margin-left:4.1cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(var1,var)</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">var=10</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">f1()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">1 25</SPAN><BR> 
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(var)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">25</SPAN><BR> 
<A NAME="2.4"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">2.4 Определение пространства имен в модулях и функциях</H4>
<P>Для получения пространства имен необходимо вызвать встроенную функцию
<SPAN CLASS="svoj">dir([object])</SPAN>, которая возвращает список имен, отсортированный по
алфавиту:
<UL CLASS="list">   
<LI> если аргумент функции dir() не указан, она возвращает список имен текущей области видимости;
<LI> если объект object (аргумент функции) имеет метод __dir__(), то вызывается этот метод,
который должен возвратить список атрибутов объекта;
<LI> если для объекта object метод __dir__() не определен, функция старается собрать как можно
больше информации, используя тип объекта и его атрибут __dict__() (если он указан).
</UL>
<P>По умолчанию поведение функции <SPAN CLASS="svoj">dir()</SPAN> зависит от типа объектов:
<UL CLASS="list">   
<LI> если объект является модулем, то возвращаемый список содержит имена атрибутов модуля;
<LI> если объект является типом или классом, то возвращаемый список содержит имена его атрибутов и
рекурсивно имена атрибутов его базовых классов;
<LI> в других случаях возвращаемый список содержит имена атрибутов объекта, имена атрибутов его
класса и рекусивно имена атрибутов базовых классов его класса.
</UL>
<P>При выполнении программы верхнего уровня текущей областью видимости будет текст модуля
<SPAN CLASS="svoj">__main__</SPAN>, загружаемый в память при вызове интерпретатора. Поэтому функция
<SPAN CLASS="svoj">dir()</SPAN>, вызванная без аргумента, возвратит список атрибутов этого модуля:
<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">dir</SPAN>
<SPAN STYLE="font-size:7mm; color:black">()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Поскольку </SPAN>в программе не были объявлены имена ни переменных, ни
функций, ни классов, то содержащиеся в списке атрибуты представляют собой пространство имен модуля
<SPAN CLASS="svoj">__main__</SPAN>, изначально для него заданное.<BR>
<SPAN CLASS="txt_abz">Для </SPAN>получения дополнительной информации можно вызвать встроенные
функции <SPAN CLASS="svoj">globals()</SPAN>
(см. <A HREF="../LAB1/lab.htm#globals">подраздел 8.1</A> лаб. раб. №1) и
<SPAN CLASS="svoj">locals()</SPAN>
(см. <A HREF="../LAB1/lab.htm#locals">подраздел 8.1</A> лаб. раб. №1), которые возвращают
соответственно глобальное и локальное пространства имен модуля в виде словарей, где ключи
представлены именами (те же имена, что возвращает функция <SPAN CLASS="svoj">dir()</SPAN>), а
значения &ndash; значениями соответствующих объектов:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">globals</SPAN>
<SPAN STYLE="font-size:7mm; color:black">()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
{'__builtins__': &lt;module 'builtins' (built-in)>, '__name__': '__main__', '__doc__': None,
'__loader__': &lt;class '_frozen_importlib.BuiltinImporter'>, '__package__': None,
 '__spec__': None} </SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">loсals</SPAN>
<SPAN STYLE="font-size:7mm; color:black">()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
{'__builtins__': &lt;module 'builtins' (built-in)>, '__name__': '__main__', '__doc__': None,
'__loader__': &lt;class '_frozen_importlib.BuiltinImporter'>, '__package__': None,
 '__spec__': None} </SPAN><BR><BR>
<SPAN CLASS="txt_abz">Также </SPAN>можно использовать встроенную функцию
<SPAN CLASS="svoj">vars()</SPAN>
(см. <A HREF="../LAB1/lab.htm#vars">подраздел 8.1</A> лаб. раб. №1), которая возвращает
значение атрибута __dict__ для модуля, класса, экземпляра класса или других объектов, имеющих
атрибут __dict__:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">vars</SPAN>
<SPAN STYLE="font-size:7mm; color:black">()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
{'__builtins__': &lt;module 'builtins' (built-in)>, '__name__': '__main__', '__doc__': None,
'__loader__': &lt;class '_frozen_importlib.BuiltinImporter'>, '__package__': None,
 '__spec__': None} </SPAN><BR><BR>
<SPAN CLASS="txt_abz">Результаты </SPAN>работы функций <SPAN CLASS="svoj">globals()</SPAN>,
<SPAN CLASS="svoj">globals()</SPAN> и <SPAN CLASS="svoj">vars()</SPAN> показывают, что:
<UL CLASS="list">   
<LI> значение атрибута __builtins__ определяет имя встроенного модуля &ndash; builtins, который
загружается автоматически при вызове компилятора и содержит имена встроенных функций, исключений и
других объектов языка Python, которые непосредственно доступны программе. Содержимое builtins можно
увидеть, вызвав функцию dir() и указав в качестве аргумента имя модуля:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">dir</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(__builtins__)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError'</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue"> . . .   </SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']</SPAN><BR><BR>
(показаны только первая и последняя строки атрибутов);
<LI> текущий модуль имеет имя (__name__) &ndash; '__main__';
<LI> строка документации (__doc__) &ndash; не указана;
<LI> загрузчик модуля (__loader__) &ndash; '_frozen_importlib.BuiltinImporter' помещен в
память;
<LI> пакет (__package__) &ndash; не указан;
<LI> спецификация для загрузки модуля (__spec__) &ndash; не указана;
<LI> для модуля пространства глобальных имен и локальных имен, а также значение атрибута __dict__
совпадают.
</UL>
<P>Добавим в программу оператор присваивания, задающий значение 25 глобальной переменной
<SPAN CLASS="svoj">x</SPAN>:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">x=25</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">25</SPAN><BR><BR>
<SPAN CLASS="txt_abz">И </SPAN>определим теперь пространство имен модуля:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">dir</SPAN>
<SPAN STYLE="font-size:7mm; color:black">()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
['__builtins__', '__doc__', '__loader__', '__name__', '__package__', 'builtins', 'x']</SPAN>.<BR><BR>
Пространств имен модуля изменилось &ndash; к нему добавилось имя переменной
<SPAN CLASS="svoj">x</SPAN>. Имя этой переменной и ее значение добавились, естественно, и в словарь
глобальных имен модуля:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">globals</SPAN>
<SPAN STYLE="font-size:7mm; color:black">()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
{'__builtins__': &lt;module 'builtins' (built-in)>, '__name__': '__main__', '__doc__': None,
'x': 25, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'>, '__package__': None,
'__spec__': None} </SPAN><BR><BR>
<SPAN CLASS="txt_abz">Добавим </SPAN>теперь в программу описание и вызов функции
<SPAN CLASS="svoj">func()</SPAN>, содержащей глобальную переменную <SPAN CLASS="svoj">y</SPAN>,
локальную переменную <SPAN CLASS="svoj">loc_x</SPAN> и вызовы функций
<SPAN CLASS="svoj">dir()</SPAN>, <SPAN CLASS="svoj">globals()</SPAN> и
<SPAN CLASS="svoj">locals()</SPAN> с выводом возвращаемых ими значений:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">x=25</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#FF8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">func</SPAN>
<SPAN STYLE="font-size:7mm; color:black">():</SPAN><BR>
<SPAN STYLE="margin-left:3.9cm; font-size:7mm; color:black">loc_x=100</SPAN><BR>
<SPAN STYLE="margin-left:3.9cm; font-size:7mm; color:#FF8000">global </SPAN>
<SPAN STYLE="font-size:7mm; color:black">y</SPAN><BR>
<SPAN STYLE="margin-left:3.9cm; font-size:7mm; color:black">y=7</SPAN><BR>
<SPAN STYLE="margin-left:3.9cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">dir</SPAN>
<SPAN STYLE="font-size:7mm; color:black">())</SPAN><BR>
<SPAN STYLE="margin-left:3.9cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">globals</SPAN>
<SPAN STYLE="font-size:7mm; color:black">())</SPAN><BR>
<SPAN STYLE="margin-left:3.9cm; font-size:7mm; color:#af00af">print</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">locals</SPAN>
<SPAN STYLE="font-size:7mm; color:black">())</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">func()</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue"> ['loc_x']</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
{'__builtins__': &lt;module 'builtins' (built-in)>, '__name__': '__main__',
'func': &lt;function func at 0x023A0588>, '__doc__': None, 'x': 25,
'__loader__': &lt;lass '_frozen_importlib.BuiltinImporter'>, '__package__': None, '__spec__': None,
'y': 7} </SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">{'loc_x': 100} </SPAN><BR><BR>
<SPAN CLASS="txt_abz">Результаты </SPAN>работы функции <SPAN CLASS="svoj">func()</SPAN>
показывают, что для локальной области видимости (блока функции):
<UL CLASS="list">   
<LI> пространство имен состоит из имени 'loc_x';
<LI> к глобальному пространству имен добавились имя функции func() и имя переменной y, объявленное
в теле функции как глобальное;
<LI> локальное пространство имен состоит из имени 'loc_x'.
</UL>
<P>Имена могут быть добавлены (только в локальное пространство имен) следующими способами:
<UL CLASS="list">   
<LI> передача формальных аргументов функции;
<LI> использование инструкции import;
<LI> определение класса или функции (добавляет в локальное пространство имен имя класса или
функции);
<LI> использование оператора присваивания;
<LI> использование цикла for (в заголовке указывается новое имя);
<LI> указывая имя во второй позиции после ключевого слова except.
</UL>
<P>Если глобальное имя не найдено в глобальном пространстве имен, его поиск производится в
пространстве встроенных имен, которое является пространством имен модуля
<SPAN CLASS="svoj">builtin</SPAN>. Этот модуль (или словарь определенных в нем имен) доступен
под глобальным именем текущего блока <SPAN CLASS="svoj">__builtins__</SPAN>. Если же имя не найдено
в пространстве встроенных имен, генерируется исключение NameError.
<A NAME="3"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4>3 Создание модулей пользователя</H4>
<P>По мере возрастания сложности программ появляется необходимость разбить их на несколько файлов
для облегчения поддержки. Также может возникнуть необходимость в многократном использовании
написанных функций в нескольких программах, не копируя их определения в каждую из программ. Во всех
этих случаях оправдана разработка модулей.<BR>
<SPAN CLASS="txt_abz">Модули </SPAN>выполняют как минимум три важных функции:
<UL CLASS="list"> 
<LI> повторное использование кода: такой код может быть загружен много раз во многих местах;
<LI> управление адресным пространством: модуль &ndash; это высокоуровневая организация программ,
это пакет имен, который избавляет вас от конфликтов. Поэтому модуль &ndash; это средство для
группировки системных компонентов;
<LI> глобализация сервисов и данных: для реализации объекта, который используется во многих
местах, достаточно написать один модуль, который будет импортирован.
</UL>
<P>Модуль на языке Python &ndash; это файл с расширением <SPAN CLASS="svoj">.py</SPAN>, содержащий
описания функций, классов, переменные и другие объекты, как правило, общей области применения.<BR>
<SPAN CLASS="txt_abz">Программы </SPAN>на языке Python тоже представляют собой файлы с расширением
<SPAN CLASS="svoj">.py</SPAN>, но в отличие от модулей, которые используются для подключения к
другим программам, предназначены для непосредственного выполнения.<BR>
<SPAN CLASS="txt_abz">Для </SPAN>создания пользовательского модуля необходимо сформировать файл с
расширением <SPAN CLASS="svoj">.py</SPAN>, содержащий необходимые объекты. В качестве примера
создадим модуль с именем <SPAN CLASS="svoj">my_module</SPAN> в виде файла
<SPAN CLASS="svoj">my_module.py</SPAN>, куда запишем описание функции
<SPAN CLASS="svoj">fibo()</SPAN>.<BR>
<SPAN CLASS="txt_abz">Для </SPAN>подключения созданного модуля к программе, как и любого другого 
(см. <A HREF="../LAB2/lab.htm#1">раздел 1"</A> лаб. раб. №2), используется оператор
<SPAN CLASS="svoj">import</SPAN>:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">import </SPAN>
<SPAN STYLE="font-size:7mm; color:black">my_module</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Оператор </SPAN><SPAN CLASS="svoj">import</SPAN> позволяет также подключать
сразу несколько модулей, перечисляя из через запятую.<BR>
<SPAN CLASS="txt_abz">При </SPAN>вызове функции <SPAN CLASS="svoj">fibo()</SPAN> ее необходимо
указать как метод модуля <SPAN CLASS="svoj">my_module</SPAN>:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">my_module.fibo(12)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]</SPAN><BR> <BR>
<SPAN CLASS="txt_abz">Непосредственный </SPAN>вызов функции <BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">fibo(12)</SPAN><BR><BR>
вызовет исключение:<BR><BR>
<SPAN STYLE="font-size:7mm; color:red">NameError: name 'fibo' is not defined</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Это </SPAN>происходит потому, что пространство имен модуля не входит в
пространство имен программы. Для того, чтобы вызвать функцию <SPAN CLASS="svoj">fibo()</SPAN>
непосредственно, т.е. так, как если бы она была описана в самой программе, необходимо использовать
оператор <SPAN CLASS="svoj">from</SPAN><BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">from </SPAN>
<SPAN STYLE="font-size:7mm; color:black">my_module.fibo(12)</SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">import </SPAN>
<SPAN STYLE="font-size:7mm; color:black">fibo</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">fibo(14)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]</SPAN><BR> <BR>
<SPAN CLASS="txt_abz">В операторе </SPAN> <SPAN CLASS="svoj">from</SPAN> можно задавать
одновременно сразу несколько объектов модуля, перечисляя их через запятую.
<A NAME="4"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4>4 Компиляция и выполнение фрагментов кода</H4>
<P> Python позволяет во время работы программы динамически осуществлять компиляцию и выполнение
отдельных фрагментом кода. Для этого используются следующие встроенные функции
(см. <A HREF="/!PYTHON/LAB1/lab.htm#8">подраздел 8.1</A>) лаб. раб. №1):
<UL CLASS="list"> 
<LI> compile() (см. <a href="#4.1">подраздел 4.1 </a>);
<LI> exec() (см. <a href="#4.2">подраздел 4.2 </a>);
<LI> eval() (см. <a href="#4.3">подраздел 4.3 </a>).
</UL>
<A NAME="4.1"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">4.1 Функция compile()</H4>
<P>Встроенная функция <SPAN CLASS="svoj">compile(source, filename, mode, flags=0,dont_inherit=False,
optimize=-1)</SPAN> &ndash; компилирует исходный код, указанный аргументом
<SPAN CLASS="svoj">source</SPAN>, в код или объект AST 
(см. <A HREF="../LAB1/lab.htm#compile">подраздел 8.1</A> лаб. раб. №1). Объекты кода могут
быть выполнены с помощью функций <SPAN CLASS="svoj">exec()</SPAN> 
(см. <a href="#4.2">подраздел 4.2 </a>) или <SPAN CLASS="svoj">eval()</SPAN>
(см. <a href="#4.3">подраздел 4.3 </a>). <BR>                                                            
<SPAN CLASS="txt_abz">Исходный </SPAN>код source может быть строкой
(см. <A HREF="../LAB2/lab.htm#2">раздел 2</A> лаб. раб. №2), типом bytes
(см. <A HREF="../LAB4/lab.htm#3.1">подраздел 3.1</A> лаб. раб. №4) или AST объектом
(для получения информации о том, как работать с AST объектами необходимо обратиться к документации
модуля <SPAN CLASS="svoj">ast</SPAN>).<BR>                                
<SPAN CLASS="txt_abz">Аргумент </SPAN> <SPAN CLASS="svoj">filename</SPAN> должен указывать имя
файла, откуда будет прочитан искодный код (если код находится в интерактивной среде разработки
&ndash; указывается значение <SPAN CLASS="svoj">'&lt;string>'</SPAN>).<BR>                                                            
<SPAN CLASS="txt_abz">Аргумент </SPAN> <SPAN CLASS="svoj">mode</SPAN> указывает вид кода, который
должен быть компилирован. Это может быть <SPAN CLASS="svoj">'exec'</SPAN>, если код состоит из
последовательности операторов (используется в большинстве случаев),
<SPAN CLASS="svoj">'eval'</SPAN> &ndash; если код состоит из единственного выражения (если указать
оператор, то возникнет исключение <SPAN CLASS="svoj">"invalid syntax"</SPAN>), или
<SPAN CLASS="svoj">'single'</SPAN>, если код состоит из единственного оператора, используемого в
интерактивном режиме (если операторов больше &ndash; они не будут выполняться).<BR>                                                            
<SPAN CLASS="txt_abz">Необязательные </SPAN>аргументы <SPAN CLASS="svoj">flags</SPAN> и
<SPAN CLASS="svoj">dont_inherit</SPAN> определяют, какие операторы
<SPAN CLASS="svoj">future_statement</SPAN>
(см. PEP 236 http://legacy.python.org/dev/peps/pep-0236/) влияют на компилящию исходного кода. <BR>
<SPAN CLASS="txt_abz">Необязательный </SPAN>аргумент <SPAN CLASS="svoj">optimize</SPAN> указывает
уровень оптимизации компилятора. Значение, принимаемое по умолчанию (-1), выбирает уровень
оптимизации интерпретатора, заданный опцией -O. Явно задавать можно следующие уровни:
<UL CLASS="list"> 
<LI> 0 &ndash; нет оптимизации, значение __debug__ равно True;
<LI> 1 &ndash; функции assert() удалены, значение __debug__ равно False;
<LI> 2 &ndash; строки документации удалены также.
</UL>
<p>Функция <SPAN CLASS="svoj">compile()</SPAN> вызывает исключение
<SPAN CLASS="svoj">SyntaxError</SPAN>, если компилируемый код неверен, и исключение
<SPAN CLASS="svoj">TypeError</SPAN>, если исходный код содержит байты null. <BR>                                                            
<SPAN CLASS="txt_abz">Отметим, </SPAN>когда компилируется строка, заданная на нескольких рядках, в
режимах <SPAN CLASS="svoj">'single'</SPAN> или <SPAN CLASS="svoj">'eval'</SPAN>, ввод может быть
завершен даже одним символом перевода на новую строку (<SPAN CLASS="svoj">\n</SPAN>).<BR>                                                            
<SPAN CLASS="txt_abz">Изменения </SPAN>в версии 3.2: разрешается использование символов перевода на
новую строку в стиле Windows и Mac. Также ввод в режиме
<SPAN CLASS="svoj">'exec'</SPAN> больше не должен заканчиваться по символу перевода на новую строку.
Добавлен параметр оптимизации. <BR>                                                            
<SPAN CLASS="txt_abz">Приведем </SPAN>пример компиляции небольшого фрагмента кода:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">my_code=</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">compile</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'''</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:green">x=5</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:green">y=x**3+1</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:green">print(y) '''</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'&lt;string>'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">, </SPAN>
<SPAN STYLE="font-size:7mm; color:green">'exec'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Переменная </SPAN><SPAN CLASS="svoj">my_code</SPAN> указывает на
скомпилированный фрагмент кода. Определим ее тип:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">type</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(my_code)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue"> &lt;class 'code'></SPAN><BR><BR>
<SPAN CLASS="txt_abz">Таким </SPAN>образом скомпилированный код имеет тип (класс)
<SPAN CLASS="svoj">code</SPAN>.<BR>
<A NAME="4.2"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">4.2 Функция exec()</H4>
<P> Встроенная функция <SPAN CLASS="svoj">exec(object[, globals[, locals]])</SPAN> поддерживает
динамическое выполнение кода языка Python
(см. <A HREF="../LAB1/lab.htm#exec">подраздел 8.1</A> лаб. раб. №1). Аргумент
<SPAN CLASS="svoj">object</SPAN> должен быть строкой или объектом типа
<SPAN CLASS="svoj">code</SPAN>. Если это строка, то производится ее грамматический разбор, как это
делается с операторами языка. После чего происходит ее выполнение (до завершения или до появления
ошибки). Если это объект типа <SPAN CLASS="svoj">code</SPAN>, то он просто выполняется. Надо быть
готовым к тому, что операторы return и yield могут не выполняться вне определения функции даже
внутри контекста кода, передаваемого функции <SPAN CLASS="svoj">exec()</SPAN>. Возвращается
значение None. <BR>
<SPAN CLASS="txt_abz">Во </SPAN>всех случаях, когда необязательная часть аргументов опущена, код
выполняется в текущем пространстве имен. Если указан только аргумент <SPAN CLASS="svoj">globals</SPAN>,
должен быть словарь, который будет использоваться как для глобальных, так и для локальных
переменных. Если указаны аргуметры <SPAN CLASS="svoj">globals</SPAN> и <SPAN CLASS="svoj">locals</SPAN>, они будут
использованы соответственно для глобальных и локальных переменных. Если указан аргумент
<SPAN CLASS="svoj">locals</SPAN>, он может быть типа отображения. Необходимо помнить, что на уровне
модуля <SPAN CLASS="svoj">globals</SPAN> и <SPAN CLASS="svoj">locals</SPAN> являются  одним и тем
же словарем. Если функция <SPAN CLASS="svoj">exec()</SPAN> получает два отдельных объекта &ndash;
<SPAN CLASS="svoj">globals</SPAN> и <SPAN CLASS="svoj">locals</SPAN>,  код будет выполняться как
будто они были объявлены в определении класса.<BR>
<SPAN CLASS="txt_abz">Если </SPAN>словарь <SPAN CLASS="svoj">globals</SPAN> не содержит значение
для ключа<SPAN CLASS="svoj">__builtins__</SPAN>,  ссылка на словарь встроенного модуля
<SPAN CLASS="svoj">builtins</SPAN> будет вставлена под этим ключем. Это можно контролировать,
поскольку <SPAN CLASS="svoj">builtins</SPAN> доступен выполняемому коду путем всключения
собственного словаря <SPAN CLASS="svoj">__builtins__</SPAN> в пространство имен
<SPAN CLASS="svoj">globals</SPAN> перед передачей кода функции <SPAN CLASS="svoj">exec()</SPAN>.<BR>
<SPAN CLASS="txt_abz">Отметим, </SPAN>во-первых, что встроенные функции
<SPAN CLASS="svoj">globals()</SPAN> и <SPAN CLASS="svoj">locals()</SPAN>
(см. <a href="#2.4">подраздел 2.4 </a>) возвращают соответственно глобальный и локальный словари,
которые могут использоваться как второй и третий аргументы функции
<SPAN CLASS="svoj">exec()</SPAN>.<BR>
<SPAN CLASS="txt_abz">Во-вторых, </SPAN>значения по умолчанию аргумента
<SPAN CLASS="svoj">locals()</SPAN> берутся так, как приведено в фукнции
<A HREF="lab1.htm#locals">locals()</A>: модификации значений по умолчанию словаря
<SPAN CLASS="svoj">locals()</SPAN> не допускаются. Необходимо явно передать словарь
<SPAN CLASS="svoj">locals()</SPAN>, если нужно увидеть влияние кода на
<SPAN CLASS="svoj">locals()</SPAN> после того, как функция <SPAN CLASS="svoj">exec()</SPAN> вернет
значение. <BR>
<SPAN CLASS="txt_abz">Приведем </SPAN>два примера использования фукнции
<SPAN CLASS="svoj">exec()</SPAN>: один с аргументом в виде строки:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">x=1.25</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">exec</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'y=x*x+x+1'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">y</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">3.8125</SPAN><BR><BR>
другой &ndash; с аргументом в виде скомпилированного кода. Для этого воспользуемся переменной
<SPAN CLASS="svoj">my_code</SPAN>, полученной в <A HREF="#4.1">подразделе 4.1</A>:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">exec</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(my_code)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">126</SPAN><BR>
<A NAME="4.3"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H4 CLASS="pod">4.3 Функция eval()</H4>
<P> Аргументами встроенной функции
<SPAN CLASS="svoj">eval(expression, globals=None, locals=None)</SPAN>
(см. <A HREF="../LAB1/lab.htm#eval">подраздел 8.1</A> лаб. работы №1) являются:
строка <SPAN CLASS="svoj">expression</SPAN>, задающая выражение, и необязательные словари
<SPAN CLASS="svoj">globals</SPAN> и <SPAN CLASS="svoj">locals</SPAN>, указывающие
пространства имен соответственно глобальных и локальных переменных
(см. <a href="#2.4">подраздел 2.4 </a>). При выполнении функции осуществляется грамматический
разбор выражения и вычисление его значения: <BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">x=5</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">eval</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'x+1'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">,{</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'x'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">:1})</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">2</SPAN><BR><BR>
<SPAN CLASS="txt_abz">Если </SPAN>аргумент <SPAN CLASS="svoj">locals</SPAN> опущен, значения
берутся из словаря <SPAN CLASS="svoj">globals</SPAN>. Если опущены оба необязательных аргумента,
выражение вычисляется в том окружении, в котором функция <SPAN CLASS="svoj">eval()</SPAN> была
вызвана:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">x=5</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">eval</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">'x+1'</SPAN>
<SPAN STYLE="font-size:7mm; color:black">)</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">6</SPAN>.<BR> <BR>
<SPAN CLASS="txt_abz">В </SPAN><A HREF="#1.1.3">подразделе 1.1.3</A> была рассмотрена функция
<SPAN CLASS="svoj">val(x, y, op)</SPAN>, выполняющая заданные арифметические операции
(<SPAN CLASS="svoj">op</SPAN>) над двумя числами (<SPAN CLASS="svoj">x</SPAN> и
<SPAN CLASS="svoj">y</SPAN>). Использование функции <SPAN CLASS="svoj">eval()</SPAN> в блоке
функции <SPAN CLASS="svoj">val()</SPAN> (новый вариант функции &ndash;
<SPAN CLASS="svoj">new_val()</SPAN>) не только делает описание функции намного компактнее: <BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#ff8000">def </SPAN>
<SPAN STYLE="font-size:7mm; color:blue">new_val</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(x, y, op):</SPAN><BR>
<SPAN STYLE="margin-left:4.0cm; font-size:7mm; color:#ff8000">return </SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">eval</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">str</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(x)+op+</SPAN>                              
<SPAN STYLE="font-size:7mm; color:#af00af">str</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(y))</SPAN>, <BR>
<p class="ba">но </SPAN> и существенно расширяет функциональные возможности функции
<SPAN CLASS="svoj">eval()</SPAN>, поскольку функция <SPAN CLASS="svoj">new_val()</SPAN> может
выполнять не только те операции, которые были предусмотрены для функции
<SPAN CLASS="svoj">val()</SPAN>:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">new_val(3, 2, '/')</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">1.5</SPAN>,<BR><BR>
но и любые двуместные операции для операндов <SPAN CLASS="svoj">x</SPAN> и
<SPAN CLASS="svoj">y</SPAN>:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">new_val(3,2,'**')</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">9</SPAN>.<BR><BR>
Причем даже такие, которых нет среди стандартных операций языка Python:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:black">new_val(3, 2, '**2+')</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">11</SPAN>.<BR><BR>
<SPAN CLASS="txt_abz">В </SPAN>заключение отметим, что <SPAN CLASS="svoj">eval(repr(object))</SPAN>
возвращает <SPAN CLASS="svoj">object</SPAN>. Например:<BR><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:#900090">>>></SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">eval</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:#af00af">repr</SPAN>
<SPAN STYLE="font-size:7mm; color:black">(</SPAN>
<SPAN STYLE="font-size:7mm; color:green">"cat"</SPAN>
<SPAN STYLE="font-size:7mm; color:black">))</SPAN><BR>
<SPAN STYLE="margin-left:1.5cm; font-size:7mm; color:blue">'cat'</SPAN>.<BR>
<A NAME="ind"></A>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>

<H3>Индивидуальные задания</H3>
<P>Разработать программу на языке Python, в которой:
<UL CLASS="list">
<LI> 1 Определена и выполнена функция func1() с аргументами в виде списка чисел (целых и с
плавающей точкой), которая выполняет операцию, заданную колонкой "Операция" табл. №1):
<UL CLASS="list2">
<LI> 1 &ndash; определение суммы квадратов элементов списка;
<LI> 2 &ndash; определение максимального числа среди элементов списка;
<LI> 3 &ndash; определение квадратных корней элементов списка;
<LI> 4 &ndash; определение минимального числа среди элементов списка;
<LI> 5 &ndash; определение среднего значения элементов списка;
<LI> 6 &ndash; определение разности между суммой четных чисел и суммой нечетных чисел (если число
не целое &ndash; привести к целому);
<LI> 7 &ndash; определение разности между суммой кубов и суммой квадратов элементов списка.
</UL>
<LI> 2.1 Создан словарь a_dict (числом элементов не меньше 8), ключи которого именуются
произвольно, а значения заданы в виде, указанном колонкой "Вид значений" табл. №1): 
<UL CLASS="list2">
<LI> 1 &ndash; латинские буквы; 
<LI> 2 &ndash; цифры; 
<LI> 3 &ndash; буквы кириллицы;
<LI> 4 &ndash; наименования встроенных функций;
<LI> 5 &ndash; наименования операторов.
</UL>
При этом отдельные ключи (числом не меньше трех) должны иметь одинаковое значение.
<LI> 2.2 Определена функция func2(), которая имеет два аргумента, первый &ndash; в виде словаря,
второй &ndash; указывает значение ключа словаря. Функция func2() возвращает список ключей
словаря, значения которых совпадают со значениями второго аргумента.
<LI> 2.3 Проверена работа функции func2(), при вызове которой в качестве первого аргумента задан
словарь a_dict, а в качестве второго аргумента &ndash; значение, которое имеют несколько ключей
словаря.
<LI> 3.1 Создан список a_list, элементы которого имеют тип, указанный колонкой "Тип" табл. №1): 
<UL CLASS="list2">
<LI> 1 &ndash; числа; 
<LI> 2 &ndash; логические значения; 
<LI> 3 &ndash; строки;
<LI> 4 &ndash; списки с элементами в виде чисел;
<LI> 5 &ndash; списки с элементами в виде строк.
</UL>
<LI> 3.2 Определена функция func3(), которая преобразует каждый элемент заданного списка a_list в 
целое число (механизм преобразования &ndash; на усмотрение студента).
<LI> 3.3 Выполнена с использованием функции func3() и метода sort() сортировка элементов списка
a_list:
<UL CLASS="list2">
<LI> для четных номеров индивидуального задания &ndash; по возрастанию; 
<LI> для нечетных номеров индивидуального задания &ndash; по убыванию.
</UL>
<LI> 4.1 Задана строка str_code, содержащая небольшой фрагмент кода на языке Python и получен
скомпилированный с помощью встроенной функции compile() код &ndash; comp_code. 
<LI> 4.2 С помощью встроенной функции exec() код comp_code исполнен.
<LI> 5 Для программы и одной из функций программы определено множество глобальных имен и множество
локальных имен.
</UL>    
<P><table align="center" width="40%" border cellspacing="0">
<CAPTION ALIGN="top"><p class="ba">Таблица 1 &ndash; Перечень индивидуальных заданий</CAPTION>
<TR><TH>Номер<BR>п/п<TH>Операция<TH>Вид значений<TH>Тип
<TR ALIGN="center"><TD>1<TD>1<TD>5<TD>1,5
<TR ALIGN="center"><TD>2<TD>2<TD>4<TD>2,3
<TR ALIGN="center"><TD>3<TD>3<TD>3<TD>2,4
<TR ALIGN="center"><TD>4<TD>4<TD>2<TD>2,5
<TR ALIGN="center"><TD>5<TD>5<TD>1<TD>3,4
<TR ALIGN="center"><TD>6<TD>6<TD>5<TD>3,5
<TR ALIGN="center"><TD>7<TD>7<TD>4<TD>1,5
<TR ALIGN="center"><TD>8<TD>1<TD>3<TD>2,3
<TR ALIGN="center"><TD>9<TD>2<TD>2<TD>2,4
<TR ALIGN="center"><TD>10<TD>3<TD>1<TD>2,5
<TR ALIGN="center"><TD>11<TD>4<TD>5<TD>3,4
<TR ALIGN="center"><TD>12<TD>5<TD>4<TD>3,5
<TR ALIGN="center"><TD>13<TD>6<TD>3<TD>1,5
<TR ALIGN="center"><TD>14<TD>7<TD>2<TD>2,3
<TR ALIGN="center"><TD>15<TD>1<TD>1<TD>2,4
<TR ALIGN="center"><TD>16<TD>2<TD>5<TD>2,5
<TR ALIGN="center"><TD>17<TD>3<TD>4<TD>3,4
<TR ALIGN="center"><TD>18<TD>4<TD>3<TD>3,5
<TR ALIGN="center"><TD>19<TD>5<TD>2<TD>1,5
<TR ALIGN="center"><TD>20<TD>6<TD>1<TD>2,3
</TABLE>
<p>&nbsp;<A CLASS="out" HREF="#beg" style="margin-left:80%">Оглавление</A>
